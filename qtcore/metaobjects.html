<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- metaobjects.qdoc -->
  <title>元对象系统 | Qt Core 6.2.3 | Qt6 中文参考手册</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li>元对象系统</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 参考文档</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar"><div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">元对象系统(The Meta-Object System)</h1>
<!-- $$$metaobjects.html-description -->
<div class="descr" id="details">
<p>Qt的元对象系统为对象间通信、运行时类型信息和动态属性系统提供了信号和槽机制。</p>
<p>元对象系统基于三件事：</p>
<ol class="1" type="1"><li><a href="qobject.html">QObject</a> 类为可以利用元对象系统的对象提供了一个基类。</li>
<li>类声明为private的 <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> 宏用于启用元对象功能，例如动态属性、信号和槽。</li>
<li><a href="../qtdoc/moc.html">元对象编译器(Meta-Object Compiler)</a> (<code>简写：moc</code>)  为每个 <a href="qobject.html">QObject</a> 子类生成实现元对象功能所需的代码。</li>
</ol>
<p><code>moc</code> 工具读取C++源文件。如果它找到一个或多个包含 <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> 宏的类声明, 它将生成另一个C++源文件，其中包含每个类的元对象代码。此生成的源文件 <code>#include</code>到类的源文件中，要么更常见的是编译并与类的实现链接。</p>
<p>除了提供 <a href="signalsandslots.html">信号和插槽</a> 机制用于对象之间的通信（引入系统的主要原因）之外，元对象代码还提供以下附加功能：</p>
<ul>
<li><a href="qobject.html#metaObject">QObject::metaObject()</a> 函数返回类的关联 <a href="qmetaobject.html">元对象(meta-object)</a> .</li>
<li><a href="qmetaobject.html#className">QMetaObject::className()</a> 在运行时以字符串形式返回类名，而无需通过C++编译器提供本机运行时类型信息 （RTTI） 支持。</li>
<li><a href="qobject.html#inherits">QObject::inherits</a>() 函数返回对象是否是在 <a href="qobject.html">QObject</a> 继承树中继承指定类名为参数className的实例</li>
<li><a href="qobject.html#tr">QObject::tr</a>() 翻译<a href="../qtdoc/internationalization.html">国际化的字符串</a>.</li>
<li><a href="qobject.html#setProperty">QObject::setProperty</a>() 和 <a href="qobject.html#property">QObject::property</a>() ，动态设置属性，和按名称获取属性。</li>
<li><a href="qmetaobject.html#newInstance">QMetaObject::newInstance</a>() 创建类的新实例。</li>
</ul>
<span id="qobjectcast"></span><p>还可以在 <a href="qobject.html">QObject</a> 类上使用<a href="qobject.html#qobject_cast-1">qobject_cast</a>() 执行动态转换。<a href="qobject.html#qobject_cast-1">qobject_cast</a>() 函数的行为类似于标准C++的  <code>dynamic_cast()</code>, 其优点是它不需要 RTTI 支持，并且可以跨动态库工作。它尝试将其参数转换为尖括号中指定的指针类型，如果对象类型正确（在运行时确定），则返回非零指针;如果对象的类型不兼容，则返回 <code>nullptr</code>.</p>
<p>例如，假设 <code>MyWidget</code> 继承自 <a href="../qtwidgets/qwidget.html">QWidget</a> 并使用<a href="qobject.html#Q_OBJECT">Q_OBJECT</a> 宏声明：</p>
<pre class="cpp">
     <span class="type"><a href="qobject.html">QObject</a></span> <span class="operator">*</span>obj <span class="operator">=</span> <span class="keyword">new</span> MyWidget;
</pre>
<p>类型为<code>QObject *</code> 的 <code>obj</code> 变量实际上引用了一个 <code>MyWidget</code> 对象，因此我们可以适当地转换它：</p>
<pre class="cpp">
     <span class="type"><a href="../qtwidgets/qwidget.html">QWidget</a></span> <span class="operator">*</span>widget <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qwidget.html">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj);
</pre>
<p>从<a href="qobject.html">QObject</a> 到 <a href="../qtwidgets/qwidget.html">QWidget</a> 的强制转换是成功的，因为该对象实际上是 <code>MyWidget</code>，它是  <a href="../qtwidgets/qwidget.html">QWidget</a>的子类。由于我们知道<code>obj</code> 是 <code>MyWidget</code>，我们也可以将其转换为 <code>MyWidget *</code>:</p>
<pre class="cpp">
     MyWidget <span class="operator">*</span>myWidget <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>MyWidget <span class="operator">*</span><span class="operator">&gt;</span>(obj);
</pre>
<p>The cast to <code>MyWidget</code> is successful because <a href="qobject.html#qobject_cast-1">qobject_cast</a>() makes no distinction between built-in Qt types and custom types.</p>
<pre class="cpp">
     <span class="type"><a href="../qtwidgets/qlabel.html">QLabel</a></span> <span class="operator">*</span>label <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qlabel.html">QLabel</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj);
     <span class="comment">// label is 0</span>
</pre>
<p>The cast to <a href="../qtwidgets/qlabel.html">QLabel</a>, on the other hand, fails. The pointer is then set to 0. This makes it possible to handle objects of different types differently at run-time, based on the type:</p>
<pre class="cpp">
     <span class="keyword">if</span> (<span class="type"><a href="../qtwidgets/qlabel.html">QLabel</a></span> <span class="operator">*</span>label <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qlabel.html">QLabel</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj)) {
         label<span class="operator">-</span><span class="operator">&gt;</span>setText(tr(<span class="string">&quot;Ping&quot;</span>));
     } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type"><a href="../qtwidgets/qpushbutton.html">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="../qtwidgets/qpushbutton.html">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj)) {
         button<span class="operator">-</span><span class="operator">&gt;</span>setText(tr(<span class="string">&quot;Pong!&quot;</span>));
     }
</pre>
<p>While it is possible to use <a href="qobject.html">QObject</a> as a base class without the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro and without meta-object code, neither signals and slots nor the other features described here will be available if the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro is not used. From the meta-object system's point of view, a <a href="qobject.html">QObject</a> subclass without meta code is equivalent to its closest ancestor with meta-object code. This means for example, that <a href="qmetaobject.html#className">QMetaObject::className</a>() will not return the actual name of your class, but the class name of this ancestor.</p>
<p>Therefore, we strongly recommend that all subclasses of <a href="qobject.html">QObject</a> use the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro regardless of whether or not they actually use signals, slots, and properties.</p>
</div>
<p><b>See also </b><a href="qmetaobject.html">QMetaObject</a>, <a href="properties.html">Qt's Property System</a>, and <a href="signalsandslots.html">Signals and Slots</a>.</p>
<!-- @@@metaobjects.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
