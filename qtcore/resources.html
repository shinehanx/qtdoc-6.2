<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- resource-system.qdoc -->
  <title>The Qt Resource System | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li>The Qt Resource System</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#the-qt-resource-compiler-rcc">The Qt Resource Compiler (rcc)</a></li>
<li class="level1"><a href="#qt-resource-collection-file-qrc">Qt Resource Collection File (.qrc)</a></li>
<li class="level1"><a href="#build-system-integration">Build System Integration</a></li>
<li class="level2"><a href="#cmake">CMake</a></li>
<li class="level2"><a href="#qmake">qmake</a></li>
<li class="level1"><a href="#runtime-api">Runtime API</a></li>
<li class="level1"><a href="#advanced-topics">Advanced Topics</a></li>
<li class="level2"><a href="#prefixes">Prefixes</a></li>
<li class="level2"><a href="#aliases">Aliases</a></li>
<li class="level2"><a href="#language-selectors">Language Selectors</a></li>
<li class="level2"><a href="#embedding-large-files">Embedding Large Files</a></li>
<li class="level2"><a href="#external-resource-files">External Resource Files</a></li>
<li class="level2"><a href="#resources-in-a-qt-for-python-application">Resources in a Qt for Python application</a></li>
<li class="level2"><a href="#compression">Compression</a></li>
<li class="level2"><a href="#explicit-loading-and-unloading-of-embedded-resources">Explicit Loading and Unloading of Embedded Resources</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">The Qt Resource System</h1>
<!-- $$$resources.html-description -->
<div class="descr" id="details">
<p>The Qt resource system is a platform-independent mechanism for shipping resource files in an application. Use it if your application always needs a certain set of files (like icons, translation files, images), and you don't want to use system-specific means to package and locate these resources.</p>
<p>Most commonly, the resource files are embedded into your application executable, or in libraries and plugins that are loaded by the application executable. Alternatively, the resource files can also be stored in an <a href="resources.html#external-resource-files">exernal resource file</a>.</p>
<p>The resource system is based on tight cooperation between Qt's <a href="../qtdoc/rcc.html">rcc</a> resource compiler, the build system, and the Qt runtime API.</p>
<div class="admonition note">
<p><b>Note: </b>Currently, the Qt resource system does not make use of any system-specific capabilities for handling resources, such as the ones on Windows, macOS, and iOS. This might change in a future Qt release.</p>
</div>
<h2 id="the-qt-resource-compiler-rcc">The Qt Resource Compiler (rcc)</h2>
<p>The <a href="../qtdoc/rcc.html">Resource Compiler (rcc)</a> command line tool reads resource files and generates either a C++ or Python source file, or an <code>.rcc</code> file.</p>
<p>The list of files and related metadata is passed to <code>rcc</code> in the form of a <a href="resources.html#qt-resource-collection-file">Qt Resource Collection File</a>.</p>
<p>By default, rcc will generate C++ source code that is then compiled as part of an executable or library. The <code>-g python</code> option generates Python source code instead. The <code>-binary</code> option generates a binary archive that is by convention saved in an <code>.rcc</code> file and can be loaded at runtime.</p>
<div class="admonition note">
<p><b>Note: </b>While it is possible to run <code>rcc</code> from the command line, this is typically best left to a build system. See also the sections about <a href="resources.html#qmake">qmake</a> and <a href="resources.html#cmake">CMake</a> below.</p>
</div>
<h2 id="qt-resource-collection-file-qrc">Qt Resource Collection File (.qrc)</h2>
<span id="qt-resource-collection-file"></span><span id="resource-collection-files"></span><p>A <code>.qrc</code> file is an XML document that enumerates local files to be included as runtime resources. It serves as input to <code>rcc</code>.</p>
<p>Here's an example <code>.qrc</code> file:</p>
<pre class="cpp">
 &lt;RCC&gt;
     &lt;qresource prefix=&quot;/&quot;&gt;
         &lt;file&gt;images/copy.png&lt;/file&gt;
         &lt;file&gt;images/cut.png&lt;/file&gt;
         &lt;file&gt;images/new.png&lt;/file&gt;
         &lt;file&gt;images/open.png&lt;/file&gt;
         &lt;file&gt;images/paste.png&lt;/file&gt;
         &lt;file&gt;images/save.png&lt;/file&gt;
     &lt;/qresource&gt;
 &lt;/RCC&gt;
</pre>
<p>Each <code>&lt;file&gt;</code> element in the XML identifies a file in the application's source tree. The path is resolved relative to the directory containing the <code>.qrc</code> file.</p>
<p>The path is also used by default to identify the file's content at runtime. That is, the file <code>copy.png</code> will be available in the resource system as <code>:/images/copy.png</code> or <code>qrc:/images/copy.png</code>. To override this default run-time name, see <a href="resources.html#prefixes">Prefixes</a> and <a href="resources.html#aliases">Aliases</a>.</p>
<p><i>Qt Creator</i>, <i>Qt Design Studio</i>, <i>Qt Designer</i>, and <i>Qt Visual Studio Tools</i> allow you to create, inspect and edit <code>.qrc</code> files through a convenient user interface. Except for <i>Qt Designer</i>, they also provide wizards for projects using the Qt resource system.</p>
<h2 id="build-system-integration">Build System Integration</h2>
<p>The processing of resource files with <code>rcc</code> is typically done at the time the application is built. Several build tools have dedicated support for this, including <a href="resources.html#cmake">CMake</a> and <a href="resources.html#qmake">qmake</a>.</p>
<h3 id="cmake">CMake</h3>
<p>If <code>CMAKE_AUTORCC</code> is enabled, you can just add <code>.qrc</code> files as sources to your executable or library. The referenced resource files will then be embedded into the binary:</p>
<pre class="cpp">
 set(CMAKE_AUTORCC ON)

 qt_add_executable(my_app
     application.qrc
     main.cpp
 )
</pre>
<p>See <a href="https://cmake.org/cmake/help/latest/prop_tgt/AUTORCC.html">CMake's AUTORCC documentation</a> for more details about AUTORCC.</p>
<p>An alternative to AUTORCC is using Qt6Core's CMake function <a href="qt-add-resources.html">qt_add_resources</a>, which gives more control over the creation of resources. For example, it allows you to specify the content of the resource directly in the project file without writing a <code>.qrc</code> file first:</p>
<pre class="cpp">
 qt_add_resources(my_app &quot;app_images&quot;
     PREFIX &quot;/&quot;
     FILES
         images/copy.png
         images/cut.png
         images/new.png
         images/open.png
         images/paste.png
         images/save.png
 )
</pre>
<p>Finally, <a href="../qtqml/qt-add-qml-module.html">qt_add_qml_module</a> allows you to embed Qt Quick resources into the resource system of your application. The function is defined in the <code>Qml</code> component of the <code>Qt6</code> CMake package.</p>
<h3 id="qmake">qmake</h3>
<p><a href="../qmake/qmake-manual.html">qmake</a> supports handing resources with the <a href="../qmake/qmake-variable-reference.html#resources">RESOURCES</a> variable. If you add a <code>.qrc</code> file path to the variable, the listed resource files will be embedded into the generated library or executable:</p>
<pre class="cpp">
 RESOURCES = application.qrc
</pre>
<p>For simple applications, it is also possible to let qmake generate the <code>.qrc</code> file for you, avoiding the need for an additional file to be maintained:</p>
<pre class="cpp">
 resources.files = \
     images/copy.png \
     images/cut.png \
     images/new.png \
     images/open.png \
     images/paste.png \
     images/save.png
 resources.prefix = /

 RESOURCES = resources
</pre>
<h2 id="runtime-api">Runtime API</h2>
<p>Qt API that deals with iterating and reading files has built-in support for the Qt Resource System. You can pass a resource path instead of a local file path to <a href="qfile.html">QFile</a> and <a href="qdir.html">QDir</a>, but also for instance to the <a href="../qtgui/qicon.html">QIcon</a>, <a href="../qtgui/qimage.html">QImage</a>, and <a href="../qtgui/qpixmap.html">QPixmap</a> constructors:</p>
<pre class="cpp">
     cutAct <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtgui/qaction.html">QAction</a></span>(<span class="type"><a href="../qtgui/qicon.html">QIcon</a></span>(<span class="string">&quot;:/images/cut.png&quot;</span>)<span class="operator">,</span> tr(<span class="string">&quot;Cu&amp;t&quot;</span>)<span class="operator">,</span> <span class="keyword">this</span>);
</pre>
<p>The <code>:</code> prefix makes it explicit that &quot;/images/cut.png&quot; should be loaded from the Qt Resource System.</p>
<p>You can also reference the Qt resource system through a <a href="qurl.html">QUrl</a>. Use the <code>qrc</code> scheme in this case:</p>
<pre class="cpp">
     <span class="type"><a href="../qtqml/qqmlapplicationengine.html">QQmlApplicationEngine</a></span> engine;
     engine<span class="operator">.</span>load(<span class="type"><a href="qurl.html">QUrl</a></span>(<span class="string">&quot;qrc:/myapp/main.qml&quot;</span>));
</pre>
<p>See the <a href="../qtwidgets/qtwidgets-mainwindows-application-example.html">Application</a> example for an actual application that uses Qt's resource system to store its icons.</p>
<h2 id="advanced-topics">Advanced Topics</h2>
<h3 id="prefixes">Prefixes</h3>
<p>A <code>.qrc</code> file can set a prefix to be added to each local file name, given in a <code>&lt;file&gt;</code> element, to get the name by which the file shall be known within the resource system.</p>
<p>Prefixes allow you to structure the resources, avoiding clashes between resource files added through different <code>.qrc</code> files in different libraries or plugins.</p>
<div class="admonition note">
<p><b>Note: </b>The <code>/qt</code> and <code>/qt-project.org</code> prefixes are reserved for documented use cases in Qt. The <a href="../qtdoc/qt-conf.html">qt.conf</a> file is for instance looked up in <code>:/qt/etc/qt.conf</code> or <code>qrc:/qt/etc/qt.conf</code>.</p>
</div>
<h3 id="aliases">Aliases</h3>
<p>Sometimes it is convenient to make a resource file available under a different path at runtime. <code>.qrc</code> files allow this by setting an <code>alias</code> attribute:</p>
<pre class="cpp">
 <span class="operator">&lt;</span>file alias<span class="operator">=</span><span class="string">&quot;cut-img.png&quot;</span><span class="operator">&gt;</span>images<span class="operator">/</span>cut<span class="operator">.</span>png<span class="operator">&lt;</span><span class="operator">/</span>file<span class="operator">&gt;</span>
</pre>
<p>The file is from the application then only accessible as <code>:/cut-img.png</code> or <code>qrc:/cut-img.png</code>.</p>
<h3 id="language-selectors">Language Selectors</h3>
<p>Some resources need to change based on the user's locale, such as translation files or icons. <a href="resources.html#resource-collection-files">Resource Collection Files</a> support this through a <code>lang</code> attribute to the <code>qresource</code> tag, specifying a suitable locale string. For example:</p>
<pre class="cpp">
 <span class="operator">&lt;</span>qresource<span class="operator">&gt;</span>
     <span class="operator">&lt;</span>file<span class="operator">&gt;</span>cut<span class="operator">.</span>jpg<span class="operator">&lt;</span><span class="operator">/</span>file<span class="operator">&gt;</span>
 <span class="operator">&lt;</span><span class="operator">/</span>qresource<span class="operator">&gt;</span>
 <span class="operator">&lt;</span>qresource lang<span class="operator">=</span><span class="string">&quot;fr&quot;</span><span class="operator">&gt;</span>
     <span class="operator">&lt;</span>file alias<span class="operator">=</span><span class="string">&quot;cut.jpg&quot;</span><span class="operator">&gt;</span>cut_fr<span class="operator">.</span>jpg<span class="operator">&lt;</span><span class="operator">/</span>file<span class="operator">&gt;</span>
 <span class="operator">&lt;</span><span class="operator">/</span>qresource<span class="operator">&gt;</span>
</pre>
<p>If the user's locale is French (i.e&#x2e;, <a href="qlocale.html#system">QLocale::system</a>().language() is French), <code>:/cut.jpg</code> or <code>qrc:/cut.jpg</code> becomes a reference to the <code>cut_fr.jpg</code> image. For other locales, <code>cut.jpg</code> is used.</p>
<p>See the <a href="qlocale.html">QLocale</a> documentation for a description of the format to use for locale strings.</p>
<p>See <a href="qfileselector.html">QFileSelector</a> for an additional mechanism to select locale-specific resources.</p>
<h3 id="embedding-large-files">Embedding Large Files</h3>
<p>By default, <code>rcc</code> embeds the resource files into executables in the form of C++ arrays. This can be problematic especially for large resources.</p>
<p>If the compiler takes too long, or even fails because of memory overflow, you can opt into a special mode where the resources are embedded as part of a two-step process. The C++ compiler only reserves enough space in the target executable or library for the resources. The actual embedding of the resource file's content and metadata is then done after the compilation and linking phase, through another rcc call.</p>
<p>For qmake, this is enabled by adding <code>resources_big</code> to the <code>CONFIG</code> variable:</p>
<pre class="cpp">
 CONFIG += resources_big
</pre>
<p>For CMake, you need to use the <a href="qt-add-bigresources.html">qt_add_big_resources</a> function:</p>
<pre class="cpp">
 qt_add_big_resources(SOURCES application.qrc)
 target_sources(my_app PRIVATE ${SOURCES})
</pre>
<h3 id="external-resource-files">External Resource Files</h3>
<p>An alternative to embedding the resource files into the binary is to store them in a separate <code>.rcc</code> file. <code>rcc</code> allows this with the <code>-binary</code> option. Such a <code>.rcc</code> file must then be loaded at runtime with <a href="qresource.html">QResource</a>.</p>
<p>For example, a set of resource data specified in a <code>.qrc</code> file can be compiled in the following way:</p>
<pre class="cpp">
 rcc <span class="operator">-</span>binary myresource<span class="operator">.</span>qrc <span class="operator">-</span>o myresource<span class="operator">.</span>rcc
</pre>
<p>In the application, this resource would be registered with code like this:</p>
<pre class="cpp">
 <span class="type"><a href="qresource.html">QResource</a></span><span class="operator">::</span>registerResource(<span class="string">&quot;/path/to/myresource.rcc&quot;</span>);
</pre>
<p>If you use CMake, you can use the <a href="qt-add-binary-resources.html">qt_add_binary_resources</a> function to schedule the <code>rcc</code> call above:</p>
<pre class="cpp">
 qt_add_binary_resources(resources application.qrc DESTINATION application.rcc)
 add_dependencies(my_app resources)
</pre>
<h3 id="resources-in-a-qt-for-python-application">Resources in a Qt for Python application</h3>
<p>The resource collection file is converted to a Python module by using the resource compiler <a href="../qtdoc/rcc.html">rcc</a>:</p>
<pre class="cpp">
 rcc <span class="operator">-</span>g python application<span class="operator">.</span>qrc <span class="operator">&gt;</span> application_rc<span class="operator">.</span>py
</pre>
<p>The module can then be imported in the application:</p>
<pre class="cpp">
 import application_rc<span class="operator">.</span>py
</pre>
<h3 id="compression">Compression</h3>
<p><code>rcc</code> attempts to compress the content to optimize disk space usage in the final binaries. By default, it will perform a heuristic check to determine whether compressing is worth it and will store the content uncompressed if it fails to sufficiently compress. To control the threshold, you can use the <code>-threshold</code> option, which tells <code>rcc</code> the percentage of the original file size that must be gained for it to store the file in compressed form.</p>
<pre class="cpp">
 rcc <span class="operator">-</span>threshold <span class="number">25</span> myresources<span class="operator">.</span>qrc
</pre>
<p>The default value is &quot;70&quot;, indicating that the compressed file must be 70% smaller than the original (no more than 30% of the original file size).</p>
<p>It is possible to turn off compression if desired. This can be useful if your resources already contain a compressed format, such as <code>.png</code> files, and you do not want to incur the CPU cost at build time to confirm that it can't be compressed. Another reason is if disk usage is not a problem and the application would prefer to keep the content as clean memory pages at runtime. You do this by giving the <code>-no-compress</code> command line argument.</p>
<pre class="cpp">
 rcc <span class="operator">-</span>no<span class="operator">-</span>compress myresources<span class="operator">.</span>qrc
</pre>
<p><code>rcc</code> also gives you some control over the compression level and compression algorithm, for example:</p>
<pre class="cpp">
 rcc <span class="operator">-</span>compress <span class="number">2</span> <span class="operator">-</span>compress<span class="operator">-</span>algo zlib myresources<span class="operator">.</span>qrc
</pre>
<p>It is also possible to use <code>threshold</code>, <code>compress</code>, and <code>compress-algo</code> as attributes in a .qrc <code>file</code> tag.</p>
<pre class="cpp">
 <span class="operator">&lt;</span>qresource<span class="operator">&gt;</span>
     <span class="operator">&lt;</span>file compress<span class="operator">=</span><span class="string">&quot;1&quot;</span> compress<span class="operator">-</span>algo<span class="operator">=</span><span class="string">&quot;zstd&quot;</span><span class="operator">&gt;</span>data<span class="operator">.</span>txt<span class="operator">&lt;</span><span class="operator">/</span>file<span class="operator">&gt;</span>
 <span class="operator">&lt;</span><span class="operator">/</span>qresource<span class="operator">&gt;</span>
</pre>
<p>The above will select the <code>zstd</code> algorithm with compression level 1.</p>
<p><code>rcc</code> supports the following compression algorithms and compression levels:</p>
<ul>
<li><code>best</code>: use the best algorithm among the ones below, at its highest compression level, to achieve the most compression at the expense of using a lot of CPU time during compilation. This value is useful in the XML file to indicate a file should be most compressed, regardless of which algorithms <code>rcc</code> supports.</li>
<li><code>zstd</code>: use the <a href="http://facebook.github.io/zstd/">Zstandard</a> library to compress contents. Valid compression levels range from 1 to 19, 1 is least compression (least CPU time) and 19 is the most compression (most CPU time). The default level is 14. A special value of 0 tells the <code>zstd</code> library to choose an implementation-defined default.</li>
<li><code>zlib</code>: use the <a href="https://zlib.net">zlib</a> library to compress contents. Valid compression levels range from 1 to 9, with 1 applying the least compression (least CPU time) and 9 the most compression (most CPU time). The special value 0 means &quot;no compression&quot; and should not be used. The default is implementation-defined, but usually is level 6.</li>
<li><code>none</code>: no compression. This is the same as the <code>-no-compress</code> option.</li>
</ul>
<p>Support for both Zstandard and zlib are optional. If a given library was not detected at compile time, attempting to pass <code>-compress-algo</code> for that library will result in an error. The default compression algorithm is <code>zstd</code> if it is enabled, <code>zlib</code> if not.</p>
<h3 id="explicit-loading-and-unloading-of-embedded-resources">Explicit Loading and Unloading of Embedded Resources</h3>
<p>Resources embedded in C++ executable or library code are automatically registered to the Qt resource system in a constructor of an internal global variable. Since the global variables are initialized before main() runs, the resources are available when the program starts to run.</p>
<p>When embedding resources in <i>static</i> libraries, the C++ linker might remove the static variables that register the resources. If you embed resources in a static library, you therefore need to explicitly register your resources by calling <a href="qdir.html#Q_INIT_RESOURCE">Q_INIT_RESOURCE</a>() with the base name of the <code>.qrc</code> file. For example:</p>
<pre class="cpp">
 MyClass<span class="operator">::</span>MyClass() : BaseClass()
 {
     Q_INIT_RESOURCE(resources);

     <span class="type"><a href="qfile.html">QFile</a></span> file(<span class="string">&quot;:/myfile.dat&quot;</span>);
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 }
</pre>
<p>You can also explicitly remove registered resources from the application, for instance when unloading a plugin. Use <a href="qdir.html#Q_CLEANUP_RESOURCE">Q_CLEANUP_RESOURCE</a>() for this.</p>
<p>Note: As the resource initializers generated by rcc are declared in the global namespace, your calls to <a href="qdir.html#Q_INIT_RESOURCE">Q_INIT_RESOURCE</a>() and <a href="qdir.html#Q_CLEANUP_RESOURCE">Q_CLEANUP_RESOURCE</a>() need to be done outside any namespace.</p>
</div>
<!-- @@@resources.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
