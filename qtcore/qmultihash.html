<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qhash.cpp -->
  <title>QMultiHash Class | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html">C++ Classes</a></li>
<li>QMultiHash</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QMultiHash Class</h1>
<span class="small-subtitle">template &lt;typename Key, typename T&gt; class QMultiHash</span>
<!-- $$$QMultiHash-brief -->
<p>The QMultiHash class is a convenience <a href="qhash.html#qhash">QHash</a> subclass that provides multi-valued hashes. <a href="#details">More...</a></p>
<!-- @@@QMultiHash -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QMultiHash&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div>
<ul>
<li><a href="qmultihash-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qdoc/17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultihash-const-iterator.html">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultihash-iterator.html">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmultihash-key-iterator.html">key_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#const_key_value_iterator-typedef">const_key_value_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#key_value_iterator-typedef">key_value_iterator</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash-5">QMultiHash</a></b>(const QHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash-2">QMultiHash</a></b>(InputIterator <i>begin</i>, InputIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash-1">QMultiHash</a></b>(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt; <i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#QMultiHash">QMultiHash</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#begin">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#begin-1">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constBegin">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constEnd">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constFind-1">constFind</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constKeyValueBegin">constKeyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#constKeyValueEnd">constKeyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#contains-1">contains</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#count-2">count</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplace">emplace</a></b>(const Key &amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplace-1">emplace</a></b>(Key &amp;&amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplaceReplace">emplaceReplace</a></b>(const Key &amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#emplaceReplace-1">emplaceReplace</a></b>(Key &amp;&amp;<i>key</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#end">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#end-1">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;QMultiHash::iterator, QMultiHash::iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#equal_range">equal_range</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;QMultiHash::const_iterator, QMultiHash::const_iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#equal_range-1">equal_range</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#find-2">find</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#find-3">find</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#insert">insert</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Key </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#key">key</a></b>(const T &amp;<i>value</i>, const Key &amp;<i>defaultKey</i> = Key()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyBegin">keyBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyEnd">keyEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueBegin">keyValueBegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueBegin-1">keyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueEnd">keyValueEnd</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keyValueEnd-1">keyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#keys">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#remove">remove</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#remove-1">remove</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#removeIf">removeIf</a></b>(Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash::iterator </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#replace">replace</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#swap">swap</a></b>(QMultiHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#take">take</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#uniqueKeys">uniqueKeys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#unite">unite</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#unite-1">unite</a></b>(const QHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#value">value</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>defaultValue</i> = T()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#values">values</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#values-1">values</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-2b">operator+</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiHash&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-2b-eq">operator+=</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-5b-5d">operator[]</a></b>(const Key &amp;<i>key</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#erase_if">erase_if</a></b>(QMultiHash&lt;Key, T&gt; &amp;<i>hash</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#qHash">qHash</a></b>(const QMultiHash&lt;Key, T&gt; &amp;<i>key</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-lt-lt">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QMultiHash&lt;Key, T&gt; &amp;<i>hash</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qmultihash.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QMultiHash&lt;Key, T&gt; &amp;<i>hash</i>)</td></tr>
</table></div>
<!-- $$$QMultiHash-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QMultiHash&lt;Key, T&gt; is one of Qt's generic <a href="containers.html">container classes</a>. It inherits <a href="qhash.html#qhash">QHash</a> and extends it with a few convenience functions that make it more suitable than <a href="qhash.html#qhash">QHash</a> for storing multi-valued hashes. A multi-valued hash is a hash that allows multiple values with the same key.</p>
<p>QMultiHash mostly mirrors <a href="qhash.html#qhash">QHash</a>'s API. For example, you can use isEmpty() to test whether the hash is empty, and you can traverse a QMultiHash using <a href="qhash.html#qhash">QHash</a>'s iterator classes (for example, <a href="qhashiterator.html">QHashIterator</a>). But opposed to <a href="qhash.html#qhash">QHash</a>, it provides an <a href="qmultihash.html#insert">insert</a>() function that allows the insertion of multiple items with the same key. The <a href="qmultihash.html#replace">replace</a>() function corresponds to <a href="qhash.html#insert">QHash::insert</a>(). It also provides convenient operator+() and operator+=().</p>
<p>Unlike <a href="qmultimap.html">QMultiMap</a>, QMultiHash does not provide and ordering of the inserted items. The only guarantee is that items that share the same key will appear consecutively, from the most recently to the least recently inserted value.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> hash1<span class="operator">,</span> hash2<span class="operator">,</span> hash3;

 hash1<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">100</span>);
 hash1<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">2000</span>);
 <span class="comment">// hash1.size() == 2</span>

 hash2<span class="operator">.</span>insert(<span class="string">&quot;plenty&quot;</span><span class="operator">,</span> <span class="number">5000</span>);
 <span class="comment">// hash2.size() == 1</span>

 hash3 <span class="operator">=</span> hash1 <span class="operator">+</span> hash2;
 <span class="comment">// hash3.size() == 3</span>
</pre>
<p>Unlike <a href="qhash.html#qhash">QHash</a>, QMultiHash provides no operator[]. Use <a href="qmultihash.html#value">value</a>() or <a href="qmultihash.html#replace">replace</a>() if you want to access the most recently inserted item with a certain key.</p>
<p>If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <a href="qlist.html">QList</a>&lt;T&gt;:</p>
<pre class="cpp">
 <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> values <span class="operator">=</span> hash<span class="operator">.</span>values(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> values<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i)
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> values<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
</pre>
<p>The items that share the same key are available from most recently to least recently inserted.</p>
<p>A more efficient approach is to call <a href="qmultihash.html#find-2">find</a>() to get the STL-style iterator for the first item with a key and iterate from there:</p>
<pre class="cpp">
 <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span><span class="operator">&lt;</span><span class="type"><a href="qstring.html">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> hash<span class="operator">.</span>find(<span class="string">&quot;plenty&quot;</span>);
 <span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> hash<span class="operator">.</span>end() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">.</span>key() <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;plenty&quot;</span>) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
     <span class="operator">+</span><span class="operator">+</span>i;
 }
</pre>
<p>QMultiHash's key and value data types must be <a href="containers.html#assignable-data-types">assignable data types</a>. You cannot, for example, store a <a href="../qtwidgets/qwidget.html">QWidget</a> as a value; instead, store a <a href="../qtwidgets/qwidget.html">QWidget</a> *. In addition, QMultiHash's key type must provide operator==(), and there must also be a <a href="qmultihash.html#qHash">qHash</a>() function in the type's namespace that returns a hash value for an argument of the key's type. See the <a href="qhash.html#qhash">QHash</a> documentation for details.</p>
</div>
<p><b>See also </b><a href="qhash.html#qhash">QHash</a>, <a href="qhashiterator.html">QHashIterator</a>, <a href="qmutablehashiterator.html">QMutableHashIterator</a>, and <a href="qmultimap.html">QMultiMap</a>.</p>
<!-- @@@QMultiHash -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_key_value_iterator -->
<h3 class="fn" id="const_key_value_iterator-typedef"><code>[since 5.10] </code>QMultiHash::<span class="name">const_key_value_iterator</span></h3>
<p>The <a href="qmap.html#const_key_value_iterator-typedef">QMap::const_key_value_iterator</a> typedef provides an STL-style const iterator for <a href="qmultihash.html">QMultiHash</a> and <a href="qmultihash.html">QMultiHash</a>.</p>
<p>QMultiHash::const_key_value_iterator is essentially the same as <a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p>This typedef was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html">QKeyValueIterator</a>.</p>
<!-- @@@const_key_value_iterator -->
<!-- $$$key_value_iterator -->
<h3 class="fn" id="key_value_iterator-typedef"><code>[since 5.10] </code>QMultiHash::<span class="name">key_value_iterator</span></h3>
<p>The <a href="qmap.html#key_value_iterator-typedef">QMap::key_value_iterator</a> typedef provides an STL-style iterator for <a href="qmultihash.html">QMultiHash</a> and <a href="qmultihash.html">QMultiHash</a>.</p>
<p>QMultiHash::key_value_iterator is essentially the same as <a href="qmultihash-iterator.html">QMultiHash::iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p>This typedef was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qkeyvalueiterator.html">QKeyValueIterator</a>.</p>
<!-- @@@key_value_iterator -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="emplaceReplace-1">template &lt;typename Args&gt; <span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">emplaceReplace</span>(<span class="type">Key</span> &amp;&amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" id="emplaceReplace">template &lt;typename Args&gt; <span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">emplaceReplace</span>(const <span class="type">Key</span> &amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3></div>
<p>Inserts a new element into the container. This new element is constructed in-place using <i>args</i> as the arguments for its construction.</p>
<p>If there is already an item with the same key in the hash, that item's value is replaced with a value constructed from <i>args</i>.</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>See also </b><a href="qmultihash.html#replace">replace</a> and <a href="qmultihash.html#emplace">emplace</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="emplace-1">template &lt;typename Args&gt; <span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">emplace</span>(<span class="type">Key</span> &amp;&amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3><h3 class="fn fngroupitem" id="emplace">template &lt;typename Args&gt; <span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">emplace</span>(const <span class="type">Key</span> &amp;<i>key</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3></div>
<p>Inserts a new element into the container. This new element is constructed in-place using <i>args</i> as the arguments for its construction.</p>
<p>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <a href="qmultihash.html#replace">replace</a>(), which overwrites the value of an existing item.)</p>
<p>Returns an iterator pointing to the new element.</p>
<p><b>See also </b><a href="qmultihash.html#insert">insert</a>.</p>
<!-- @@@ -->
<!-- $$$QMultiHash$$$QMultiHashconstQHash<Key,T>& -->
<h3 class="fn" id="QMultiHash-5">QMultiHash::<span class="name">QMultiHash</span>(const <span class="type"><a href="qhash.html">QHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i>other</i> (which can be a <a href="qhash.html#qhash">QHash</a> or a QMultiHash).</p>
<!-- @@@QMultiHash -->
<!-- $$$QMultiHash$$$QMultiHashInputIteratorInputIterator -->
<h3 class="fn" id="QMultiHash-2"><code>[since 5.14] </code>template &lt;typename InputIterator&gt; QMultiHash::<span class="name">QMultiHash</span>(<span class="type">InputIterator</span> <i>begin</i>, <span class="type">InputIterator</span> <i>end</i>)</h3>
<p>Constructs a multi-hash with a copy of each of the elements in the iterator range [<i>begin</i>, <i>end</i>). Either the elements iterated by the range must be objects with <code>first</code> and <code>second</code> data members (like <code>QPair</code>, <code>std::pair</code>, etc.) convertible to <code>Key</code> and to <code>T</code> respectively; or the iterators must have <code>key()</code> and <code>value()</code> member functions, returning a key convertible to <code>Key</code> and a value convertible to <code>T</code> respectively.</p>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@QMultiHash -->
<!-- $$$QMultiHash$$$QMultiHashstd::initializer_list<std::pair<Key,T>> -->
<h3 class="fn" id="QMultiHash-1"><code>[since 5.1] </code>QMultiHash::<span class="name">QMultiHash</span>(<span class="type">std::initializer_list</span>&lt;<span class="type">std::pair</span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt;&gt; <i>list</i>)</h3>
<p>Constructs a multi-hash with a copy of each of the elements in the initializer list <i>list</i>.</p>
<p>This function is only available if the program is being compiled in C++11 mode.</p>
<p>This function was introduced in Qt 5.1.</p>
<!-- @@@QMultiHash -->
<!-- $$$QMultiHash[overload1]$$$QMultiHash -->
<h3 class="fn" id="QMultiHash">QMultiHash::<span class="name">QMultiHash</span>()</h3>
<p>Constructs an empty hash.</p>
<!-- @@@QMultiHash -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin"><span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#constBegin">constBegin</a>() and <a href="qmultihash.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1"><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">begin</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin"><code>[since 5.0] </code><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the hash.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="qmultihash.html#begin">begin</a>() and <a href="qmultihash.html#cend">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><code>[since 5.0] </code><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the hash.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="qmultihash.html#cbegin">cbegin</a>() and <a href="qmultihash.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><span class="type">void</span> QMultiHash::<span class="name">clear</span>()</h3>
<p>Removes all items from the hash and frees up all memory used by it.</p>
<p><b>See also </b><a href="qmultihash.html#remove">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin"><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#begin">begin</a>() and <a href="qmultihash.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd"><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#constBegin">constBegin</a>() and <a href="qmultihash.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind$$$constFindconstKey&constT& -->
<h3 class="fn" id="constFind-1"><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">constFind</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns an iterator pointing to the item with the <i>key</i> and the <i>value</i> in the hash.</p>
<p>If the hash contains no such item, the function returns <a href="qmultihash.html#constEnd">constEnd</a>().</p>
<!-- @@@constFind -->
<!-- $$$constKeyValueBegin[overload1]$$$constKeyValueBegin -->
<h3 class="fn" id="constKeyValueBegin"><code>[since 5.10] </code><span class="type"><a href="qmultihash.html#const_key_value_iterator-typedef">QMultiHash::const_key_value_iterator</a></span> QMultiHash::<span class="name">constKeyValueBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first entry in the hash.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueBegin">keyValueBegin</a>().</p>
<!-- @@@constKeyValueBegin -->
<!-- $$$constKeyValueEnd[overload1]$$$constKeyValueEnd -->
<h3 class="fn" id="constKeyValueEnd"><code>[since 5.10] </code><span class="type"><a href="qmultihash.html#const_key_value_iterator-typedef">QMultiHash::const_key_value_iterator</a></span> QMultiHash::<span class="name">constKeyValueEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary entry after the last entry in the hash.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qmultihash.html#constKeyValueBegin">constKeyValueBegin</a>().</p>
<!-- @@@constKeyValueEnd -->
<!-- $$$contains$$$containsconstKey&constT& -->
<h3 class="fn" id="contains-1"><span class="type">bool</span> QMultiHash::<span class="name">contains</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns <code>true</code> if the hash contains an item with the <i>key</i> and <i>value</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b>contains().</p>
<!-- @@@contains -->
<!-- $$$count$$$countconstKey&constT& -->
<h3 class="fn" id="count-2"><span class="type">qsizetype</span> QMultiHash::<span class="name">count</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>Returns the number of items with the <i>key</i> and <i>value</i>.</p>
<p><b>See also </b>count().</p>
<!-- @@@count -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the hash.</p>
<p><b>See also </b><a href="qmultihash.html#begin">begin</a>() and <a href="qmultihash.html#constEnd">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1"><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">end</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$equal_range[overload1]$$$equal_rangeconstKey& -->
<h3 class="fn" id="equal_range"><code>[since 5.7] </code><span class="type">QPair</span>&lt;<span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span>, <span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span>&gt; QMultiHash::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns a pair of iterators delimiting the range of values <code>[first, second)</code>, that are stored under <i>key</i>. If the range is empty then both iterators will be equal to <a href="qmultihash.html#end">end</a>().</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@equal_range -->
<!-- $$$equal_range$$$equal_rangeconstKey& -->
<h3 class="fn" id="equal_range-1"><code>[since 5.7] </code><span class="type">QPair</span>&lt;<span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span>, <span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span>&gt; QMultiHash::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@equal_range -->
<!-- $$$find$$$findconstKey&constT& -->
<h3 class="fn" id="find-2"><span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Returns an iterator pointing to the item with the <i>key</i> and <i>value</i>. If the hash contains no such item, the function returns <a href="qmultihash.html#end">end</a>().</p>
<p>If the hash contains multiple items with the <i>key</i> and <i>value</i>, the iterator returned points to the most recently inserted item.</p>
<!-- @@@find -->
<!-- $$$find$$$findconstKey&constT& -->
<h3 class="fn" id="find-3"><span class="type"><a href="qmultihash-const-iterator.html">QMultiHash::const_iterator</a></span> QMultiHash::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@find -->
<!-- $$$insert[overload1]$$$insertconstKey&constT& -->
<h3 class="fn" id="insert"><span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">insert</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts a new item with the <i>key</i> and a value of <i>value</i>.</p>
<p>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from <a href="qmultihash.html#replace">replace</a>(), which overwrites the value of an existing item.)</p>
<p><b>See also </b><a href="qmultihash.html#replace">replace</a>().</p>
<!-- @@@insert -->
<!-- $$$key[overload1]$$$keyconstT&constKey& -->
<h3 class="fn" id="key"><span class="type">Key</span> QMultiHash::<span class="name">key</span>(const <span class="type">T</span> &amp;<i>value</i>, const <span class="type">Key</span> &amp;<i>defaultKey</i> = Key()) const</h3>
<p>Returns the first key mapped to <i>value</i>, or <i>defaultKey</i> if the hash contains no item mapped to <i>value</i>.</p>
<p>This function can be slow (<a href="containers.html#linear-time">linear time</a>), because <a href="qmultihash.html">QMultiHash</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<!-- @@@key -->
<!-- $$$keyBegin[overload1]$$$keyBegin -->
<h3 class="fn" id="keyBegin"><code>[since 5.6] </code><span class="type"><a href="qmultihash-key-iterator.html">QMultiHash::key_iterator</a></span> QMultiHash::<span class="name">keyBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first key in the hash.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qmultihash.html#keyEnd">keyEnd</a>().</p>
<!-- @@@keyBegin -->
<!-- $$$keyEnd[overload1]$$$keyEnd -->
<h3 class="fn" id="keyEnd"><code>[since 5.6] </code><span class="type"><a href="qmultihash-key-iterator.html">QMultiHash::key_iterator</a></span> QMultiHash::<span class="name">keyEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last key in the hash.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qmultihash.html#keyBegin">keyBegin</a>().</p>
<!-- @@@keyEnd -->
<!-- $$$keyValueBegin[overload1]$$$keyValueBegin -->
<h3 class="fn" id="keyValueBegin"><code>[since 5.10] </code><span class="type"><a href="qmultihash.html#key_value_iterator-typedef">QMultiHash::key_value_iterator</a></span> QMultiHash::<span class="name">keyValueBegin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first entry in the hash.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueEnd">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueBegin$$$keyValueBegin -->
<h3 class="fn" id="keyValueBegin-1"><code>[since 5.10] </code><span class="type"><a href="qmultihash.html#const_key_value_iterator-typedef">QMultiHash::const_key_value_iterator</a></span> QMultiHash::<span class="name">keyValueBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first entry in the hash.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueEnd">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueEnd[overload1]$$$keyValueEnd -->
<h3 class="fn" id="keyValueEnd"><code>[since 5.10] </code><span class="type"><a href="qmultihash.html#key_value_iterator-typedef">QMultiHash::key_value_iterator</a></span> QMultiHash::<span class="name">keyValueEnd</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary entry after the last entry in the hash.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueBegin">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keyValueEnd$$$keyValueEnd -->
<h3 class="fn" id="keyValueEnd-1"><code>[since 5.10] </code><span class="type"><a href="qmultihash.html#const_key_value_iterator-typedef">QMultiHash::const_key_value_iterator</a></span> QMultiHash::<span class="name">keyValueEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary entry after the last entry in the hash.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qmultihash.html#keyValueBegin">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" id="keys"><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiHash::<span class="name">keys</span>() const</h3>
<p>Returns a list containing all the keys in the hash, in an arbitrary order. Keys that occur multiple times in the hash also occur multiple times in the list.</p>
<p>The order is guaranteed to be the same as that used by <a href="qmultihash.html#values">values</a>().</p>
<p>This function creates a new list, in <a href="containers.html#linear-time">linear time</a>. The time and memory use that entails can be avoided by iterating from <a href="qmultihash.html#keyBegin">keyBegin</a>() to <a href="qmultihash.html#keyEnd">keyEnd</a>().</p>
<p><b>See also </b><a href="qmultihash.html#values">values</a>() and <a href="qmultihash.html#key">key</a>().</p>
<!-- @@@keys -->
<!-- $$$remove[overload1]$$$removeconstKey& -->
<h3 class="fn" id="remove"><span class="type">qsizetype</span> QMultiHash::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Removes all the items that have the <i>key</i> from the hash. Returns the number of items removed.</p>
<p><b>See also </b>remove().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstKey&constT& -->
<h3 class="fn" id="remove-1"><span class="type">qsizetype</span> QMultiHash::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Removes all the items that have the <i>key</i> and the value <i>value</i> from the hash. Returns the number of items removed.</p>
<p><b>See also </b><a href="qmultihash.html#remove">remove</a>().</p>
<!-- @@@remove -->
<!-- $$$removeIf[overload1]$$$removeIfPredicate -->
<h3 class="fn" id="removeIf"><code>[since 6.1] </code>template &lt;typename Predicate&gt; <span class="type">qsizetype</span> QMultiHash::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i>pred</i> returns true from the multi hash.</p>
<p>The function supports predicates which take either an argument of type <code>QMultiHash&lt;Key, T&gt;::iterator</code>, or an argument of type <code>std::pair&lt;const Key &amp;, T &amp;&gt;</code>.</p>
<p>Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qmultihash.html#clear">clear</a>() and <a href="qmultihash.html#take">take</a>().</p>
<!-- @@@removeIf -->
<!-- $$$replace[overload1]$$$replaceconstKey&constT& -->
<h3 class="fn" id="replace"><span class="type"><a href="qmultihash-iterator.html">QMultiHash::iterator</a></span> QMultiHash::<span class="name">replace</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)</h3>
<p>Inserts a new item with the <i>key</i> and a value of <i>value</i>.</p>
<p>If there is already an item with the <i>key</i>, that item's value is replaced with <i>value</i>.</p>
<p>If there are multiple items with the <i>key</i>, the most recently inserted item's value is replaced with <i>value</i>.</p>
<p><b>See also </b><a href="qmultihash.html#insert">insert</a>().</p>
<!-- @@@replace -->
<!-- $$$swap[overload1]$$$swapQMultiHash<Key,T>& -->
<h3 class="fn" id="swap"><span class="type">void</span> QMultiHash::<span class="name">swap</span>(<span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Swaps hash <i>other</i> with this hash. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$take[overload1]$$$takeconstKey& -->
<h3 class="fn" id="take"><span class="type">T</span> QMultiHash::<span class="name">take</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Removes the item with the <i>key</i> from the hash and returns the value associated with it.</p>
<p>If the item does not exist in the hash, the function simply returns a <a href="containers.html#default-constructed-value">default-constructed value</a>. If there are multiple items for <i>key</i> in the hash, only the most recently inserted one is removed.</p>
<p>If you don't use the return value, <a href="qmultihash.html#remove">remove</a>() is more efficient.</p>
<p><b>See also </b><a href="qmultihash.html#remove">remove</a>().</p>
<!-- @@@take -->
<!-- $$$uniqueKeys[overload1]$$$uniqueKeys -->
<h3 class="fn" id="uniqueKeys"><code>[since 5.13] </code><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">Key</span>&gt; QMultiHash::<span class="name">uniqueKeys</span>() const</h3>
<p>Returns a list containing all the keys in the map. Keys that occur multiple times in the map occur only once in the returned list.</p>
<p>This function was introduced in Qt 5.13.</p>
<p><b>See also </b><a href="qmultihash.html#keys">keys</a>() and <a href="qmultihash.html#values">values</a>().</p>
<!-- @@@uniqueKeys -->
<!-- $$$unite[overload1]$$$uniteconstQMultiHash<Key,T>& -->
<h3 class="fn" id="unite"><code>[since 5.13] </code><span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiHash::<span class="name">unite</span>(const <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i>other</i> hash into this hash and returns a reference to this hash.</p>
<p>This function was introduced in Qt 5.13.</p>
<p><b>See also </b><a href="qmultihash.html#insert">insert</a>().</p>
<!-- @@@unite -->
<!-- $$$unite$$$uniteconstQHash<Key,T>& -->
<h3 class="fn" id="unite-1"><code>[since 6.0] </code><span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiHash::<span class="name">unite</span>(const <span class="type"><a href="qhash.html">QHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i>other</i> hash into this hash and returns a reference to this hash.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qmultihash.html#insert">insert</a>().</p>
<!-- @@@unite -->
<!-- $$$value[overload1]$$$valueconstKey&constT& -->
<h3 class="fn" id="value"><span class="type">T</span> QMultiHash::<span class="name">value</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>defaultValue</i> = T()) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the value associated with the <i>key</i>.</p>
<p>If the hash contains no item with the <i>key</i>, the function returns <i>defaultValue</i>, which is a <a href="containers.html#default-constructed-value">default-constructed value</a> if the parameter has not been specified.</p>
<p>If there are multiple items for the <i>key</i> in the hash, the value of the most recently inserted one is returned.</p>
<!-- @@@value -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn" id="values"><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; QMultiHash::<span class="name">values</span>() const</h3>
<p>Returns a list containing all the values in the hash, in an arbitrary order. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</p>
<p>The order is guaranteed to be the same as that used by <a href="qmultihash.html#keys">keys</a>().</p>
<p>This function creates a new list, in <a href="containers.html#linear-time">linear time</a>. The time and memory use that entails can be avoided by iterating from <a href="qmultihash.html#keyValueBegin">keyValueBegin</a>() to <a href="qmultihash.html#keyValueEnd">keyValueEnd</a>().</p>
<p><b>See also </b><a href="qmultihash.html#keys">keys</a>() and <a href="qmultihash.html#value">value</a>().</p>
<!-- @@@values -->
<!-- $$$values$$$valuesconstKey& -->
<h3 class="fn" id="values-1"><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; QMultiHash::<span class="name">values</span>(const <span class="type">Key</span> &amp;<i>key</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a list of all the values associated with the <i>key</i>, from the most recently inserted to the least recently inserted.</p>
<p><b>See also </b><a href="qmultihash.html#count-2">count</a>() and <a href="qmultihash.html#insert">insert</a>().</p>
<!-- @@@values -->
<!-- $$$operator+[overload1]$$$operator+constQMultiHash<Key,T>& -->
<h3 class="fn" id="operator-2b"><span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; QMultiHash::<span class="name">operator+</span>(const <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>) const</h3>
<p>Returns a hash that contains all the items in this hash in addition to all the items in <i>other</i>. If a key is common to both hashes, the resulting hash will contain the key multiple times.</p>
<p><b>See also </b><a href="qmultihash.html#operator-2b-eq">operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=constQMultiHash<Key,T>& -->
<h3 class="fn" id="operator-2b-eq"><span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMultiHash::<span class="name">operator+=</span>(const <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)</h3>
<p>Inserts all the items in the <i>other</i> hash into this hash and returns a reference to this hash.</p>
<p><b>See also </b><a href="qmultihash.html#unite">unite</a>() and <a href="qmultihash.html#insert">insert</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator[][overload1]$$$operator[]constKey& -->
<h3 class="fn" id="operator-5b-5d"><span class="type">T</span> &amp;QMultiHash::<span class="name">operator[]</span>(const <span class="type">Key</span> &amp;<i>key</i>)</h3>
<p>Returns the value associated with the <i>key</i> as a modifiable reference.</p>
<p>If the hash contains no item with the <i>key</i>, the function inserts a <a href="containers.html#default-constructed-value">default-constructed value</a> into the hash with the <i>key</i>, and returns a reference to it.</p>
<p>If the hash contains multiple items with the <i>key</i>, this function returns a reference to the most recently inserted value.</p>
<p><b>See also </b><a href="qmultihash.html#insert">insert</a>() and <a href="qmultihash.html#value">value</a>().</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$erase_if[overload1]$$$erase_ifQMultiHash<Key,T>&Predicate -->
<h3 class="fn" id="erase_if"><code>[since 6.1] </code>template &lt;typename Key, typename T, typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>hash</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i>pred</i> returns true from the multi hash <i>hash</i>.</p>
<p>The function supports predicates which take either an argument of type <code>QMultiHash&lt;Key, T&gt;::iterator</code>, or an argument of type <code>std::pair&lt;const Key &amp;, T &amp;&gt;</code>.</p>
<p>Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@erase_if -->
<!-- $$$qHash[overload1]$$$qHashconstQMultiHash<Key,T>&size_t -->
<h3 class="fn" id="qHash"><code>[since 5.8] </code>template &lt;typename Key, typename T&gt; <span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for the <i>key</i>, using <i>seed</i> to seed the calculation.</p>
<p>Type <code>T</code> must be supported by qHash().</p>
<p>This function was introduced in Qt 5.8.</p>
<!-- @@@qHash -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQMultiHash<Key,T>& -->
<h3 class="fn" id="operator-lt-lt">template &lt;typename Key, typename T&gt; <span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>hash</i>)</h3>
<p>Writes the hash <i>hash</i> to stream <i>out</i>.</p>
<p>This function requires the key and value types to implement <code>operator&lt;&lt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QMultiHash<Key,T>& -->
<h3 class="fn" id="operator-gt-gt">template &lt;typename Key, typename T&gt; <span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qmultihash.html#QMultiHash">QMultiHash</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>hash</i>)</h3>
<p>Reads a hash from stream <i>in</i> into <i>hash</i>.</p>
<p>This function requires the key and value types to implement <code>operator&gt;&gt;()</code>.</p>
<p><b>See also </b><a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
