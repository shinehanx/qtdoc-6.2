<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmetacontainer.cpp -->
  <title>QMetaSequence Class | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html">C++ Classes</a></li>
<li>QMetaSequence</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QMetaSequence Class</h1>
<!-- $$$QMetaSequence-brief -->
<p>The QMetaSequence class allows type erased access to sequential containers. <a href="#details">More...</a></p>
<!-- @@@QMetaSequence -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QMetaSequence&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> QMetaContainer</td></tr></table></div>
<ul>
<li><a href="qmetasequence-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#addValue">addValue</a></b>(void *<i>container</i>, const void *<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#addValueAtBegin">addValueAtBegin</a></b>(void *<i>container</i>, const void *<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#addValueAtEnd">addValueAtEnd</a></b>(void *<i>container</i>, const void *<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canAddValue">canAddValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canEraseRangeAtIterator">canEraseRangeAtIterator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canEraseValueAtIterator">canEraseValueAtIterator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canGetValueAtConstIterator">canGetValueAtConstIterator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canGetValueAtIndex">canGetValueAtIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canGetValueAtIterator">canGetValueAtIterator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canInsertValueAtIterator">canInsertValueAtIterator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canRemoveValue">canRemoveValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canSetValueAtIndex">canSetValueAtIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#canSetValueAtIterator">canSetValueAtIterator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#eraseRangeAtIterator">eraseRangeAtIterator</a></b>(void *<i>container</i>, const void *<i>iterator1</i>, const void *<i>iterator2</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#eraseValueAtIterator">eraseValueAtIterator</a></b>(void *<i>container</i>, const void *<i>iterator</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#insertValueAtIterator">insertValueAtIterator</a></b>(void *<i>container</i>, const void *<i>iterator</i>, const void *<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#isSortable">isSortable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#removeValue">removeValue</a></b>(void *<i>container</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#removeValueAtBegin">removeValueAtBegin</a></b>(void *<i>container</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#removeValueAtEnd">removeValueAtEnd</a></b>(void *<i>container</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#setValueAtIndex">setValueAtIndex</a></b>(void *<i>container</i>, qsizetype <i>index</i>, const void *<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#setValueAtIterator">setValueAtIterator</a></b>(const void *<i>iterator</i>, const void *<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#valueAtConstIterator">valueAtConstIterator</a></b>(const void *<i>iterator</i>, void *<i>result</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#valueAtIndex">valueAtIndex</a></b>(const void *<i>container</i>, qsizetype <i>index</i>, void *<i>result</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#valueAtIterator">valueAtIterator</a></b>(const void *<i>iterator</i>, void *<i>result</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMetaType </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#valueMetaType">valueMetaType</a></b>() const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QMetaSequence </td><td class="memItemRight bottomAlign"><b><a href="qmetasequence.html#fromContainer">fromContainer</a></b>()</td></tr>
</table></div>
<!-- $$$QMetaSequence-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The class provides a number of primitive container operations, using void* as operands. This way, you can manipulate a generic container retrieved from a Variant without knowing its type.</p>
<p>The void* arguments to the various methods are typically created by using a <a href="qvariant.html">QVariant</a> of the respective container or value type, and calling its <a href="qvariant.html#data">QVariant::data</a>() or <a href="qvariant.html#constData">QVariant::constData</a>() methods. However, you can also pass plain pointers to objects of the container or value type.</p>
<p>Iterator invalidation follows the rules given by the underlying containers and is not expressed in the API. Therefore, for a truly generic container, any iterators should be considered invalid after any write operation.</p>
</div>
<!-- @@@QMetaSequence -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$addValue[overload1]$$$addValuevoid*constvoid* -->
<h3 class="fn" id="addValue"><span class="type">void</span> QMetaSequence::<span class="name">addValue</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>value</i>) const</h3>
<p>Adds <i>value</i> to the <i>container</i> if possible. If <a href="qmetasequence.html#canAddValue">canAddValue</a>() returns <code>false</code>, the <i>value</i> is not added. Else, if <a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a>() returns <code>true</code>, the <i>value</i> is added to the end of the <i>container</i>. Else, if <a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a>() returns <code>true</code>, the <i>value</i> is added to the beginning of the container. Else, the value is added in an unspecified place or not at all. The latter is the case for adding values to an unordered container, for example <a href="qset.html">QSet</a>.</p>
<p><b>See also </b><a href="qmetasequence.html#canAddValue">canAddValue</a>(), <a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a>(), <a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), and <a href="qmetasequence.html#removeValue">removeValue</a>().</p>
<!-- @@@addValue -->
<!-- $$$addValueAtBegin[overload1]$$$addValueAtBeginvoid*constvoid* -->
<h3 class="fn" id="addValueAtBegin"><span class="type">void</span> QMetaSequence::<span class="name">addValueAtBegin</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>value</i>) const</h3>
<p>Adds <i>value</i> to the beginning of <i>container</i> if possible. If <a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a>() returns <code>false</code>, the <i>value</i> is not added.</p>
<p><b>See also </b><a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), and <a href="qmetasequence.html#removeValueAtBegin">removeValueAtBegin</a>().</p>
<!-- @@@addValueAtBegin -->
<!-- $$$addValueAtEnd[overload1]$$$addValueAtEndvoid*constvoid* -->
<h3 class="fn" id="addValueAtEnd"><span class="type">void</span> QMetaSequence::<span class="name">addValueAtEnd</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>value</i>) const</h3>
<p>Adds <i>value</i> to the end of <i>container</i> if possible. If <a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a>() returns <code>false</code>, the <i>value</i> is not added.</p>
<p><b>See also </b><a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), and <a href="qmetasequence.html#removeValueAtEnd">removeValueAtEnd</a>().</p>
<!-- @@@addValueAtEnd -->
<!-- $$$canAddValue[overload1]$$$canAddValue -->
<h3 class="fn" id="canAddValue"><span class="type">bool</span> QMetaSequence::<span class="name">canAddValue</span>() const</h3>
<p>Returns <code>true</code> if values can be added to the container, <code>false</code> otherwise.</p>
<p><b>See also </b><a href="qmetasequence.html#addValue">addValue</a>() and <a href="qmetasequence.html#isSortable">isSortable</a>().</p>
<!-- @@@canAddValue -->
<!-- $$$canAddValueAtBegin[overload1]$$$canAddValueAtBegin -->
<h3 class="fn" id="canAddValueAtBegin"><span class="type">bool</span> QMetaSequence::<span class="name">canAddValueAtBegin</span>() const</h3>
<p>Returns <code>true</code> if values added using <a href="qmetasequence.html#addValue">addValue</a>() can be placed at the beginning of the container, otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qmetasequence.html#addValueAtBegin">addValueAtBegin</a>() and <a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a>().</p>
<!-- @@@canAddValueAtBegin -->
<!-- $$$canAddValueAtEnd[overload1]$$$canAddValueAtEnd -->
<h3 class="fn" id="canAddValueAtEnd"><span class="type">bool</span> QMetaSequence::<span class="name">canAddValueAtEnd</span>() const</h3>
<p>Returns <code>true</code> if values added using <a href="qmetasequence.html#addValue">addValue</a>() can be placed at the end of the container, otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qmetasequence.html#addValueAtEnd">addValueAtEnd</a>() and <a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a>().</p>
<!-- @@@canAddValueAtEnd -->
<!-- $$$canEraseRangeAtIterator[overload1]$$$canEraseRangeAtIterator -->
<h3 class="fn" id="canEraseRangeAtIterator"><span class="type">bool</span> QMetaSequence::<span class="name">canEraseRangeAtIterator</span>() const</h3>
<p>Returns <code>true</code> if a range between two iterators can be erased from the container, <code>false</code> otherwise.</p>
<!-- @@@canEraseRangeAtIterator -->
<!-- $$$canEraseValueAtIterator[overload1]$$$canEraseValueAtIterator -->
<h3 class="fn" id="canEraseValueAtIterator"><span class="type">bool</span> QMetaSequence::<span class="name">canEraseValueAtIterator</span>() const</h3>
<p>Returns <code>true</code> if the value pointed to by a non-const iterator can be erased, <code>false</code> otherwise.</p>
<p><b>See also </b><a href="qmetacontainer.html#hasIterator">hasIterator</a>() and <a href="qmetasequence.html#eraseValueAtIterator">eraseValueAtIterator</a>().</p>
<!-- @@@canEraseValueAtIterator -->
<!-- $$$canGetValueAtConstIterator[overload1]$$$canGetValueAtConstIterator -->
<h3 class="fn" id="canGetValueAtConstIterator"><span class="type">bool</span> QMetaSequence::<span class="name">canGetValueAtConstIterator</span>() const</h3>
<p>Returns <code>true</code> if the underlying container can retrieve the value pointed to by a const iterator, <code>false</code> otherwise.</p>
<p><b>See also </b><a href="qmetacontainer.html#hasConstIterator">hasConstIterator</a>() and <a href="qmetasequence.html#valueAtConstIterator">valueAtConstIterator</a>().</p>
<!-- @@@canGetValueAtConstIterator -->
<!-- $$$canGetValueAtIndex[overload1]$$$canGetValueAtIndex -->
<h3 class="fn" id="canGetValueAtIndex"><span class="type">bool</span> QMetaSequence::<span class="name">canGetValueAtIndex</span>() const</h3>
<p>Returns <code>true</code> if values can be retrieved from the container by index, otherwise <code>false</code>.</p>
<p><b>See also </b><a href="qmetasequence.html#valueAtIndex">valueAtIndex</a>().</p>
<!-- @@@canGetValueAtIndex -->
<!-- $$$canGetValueAtIterator[overload1]$$$canGetValueAtIterator -->
<h3 class="fn" id="canGetValueAtIterator"><span class="type">bool</span> QMetaSequence::<span class="name">canGetValueAtIterator</span>() const</h3>
<p>Returns <code>true</code> if the underlying container can retrieve the value pointed to by a non-const iterator, <code>false</code> otherwise.</p>
<p><b>See also </b><a href="qmetacontainer.html#hasIterator">hasIterator</a>() and <a href="qmetasequence.html#valueAtIterator">valueAtIterator</a>().</p>
<!-- @@@canGetValueAtIterator -->
<!-- $$$canInsertValueAtIterator[overload1]$$$canInsertValueAtIterator -->
<h3 class="fn" id="canInsertValueAtIterator"><span class="type">bool</span> QMetaSequence::<span class="name">canInsertValueAtIterator</span>() const</h3>
<p>Returns <code>true</code> if the underlying container can insert a new value, taking the location pointed to by a non-const iterator into account.</p>
<p><b>See also </b><a href="qmetacontainer.html#hasIterator">hasIterator</a>() and <a href="qmetasequence.html#insertValueAtIterator">insertValueAtIterator</a>().</p>
<!-- @@@canInsertValueAtIterator -->
<!-- $$$canRemoveValue[overload1]$$$canRemoveValue -->
<h3 class="fn" id="canRemoveValue"><span class="type">bool</span> QMetaSequence::<span class="name">canRemoveValue</span>() const</h3>
<p>Returns <code>true</code> if values can be removed from the container, <code>false</code> otherwise.</p>
<p><b>See also </b><a href="qmetasequence.html#removeValue">removeValue</a>() and <a href="qmetasequence.html#isSortable">isSortable</a>().</p>
<!-- @@@canRemoveValue -->
<!-- $$$canRemoveValueAtBegin[overload1]$$$canRemoveValueAtBegin -->
<h3 class="fn" id="canRemoveValueAtBegin"><span class="type">bool</span> QMetaSequence::<span class="name">canRemoveValueAtBegin</span>() const</h3>
<p>Returns <code>true</code> if values can be removed from the beginning of the container using <a href="qmetasequence.html#removeValue">removeValue</a>() can be placed at the, otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qmetasequence.html#removeValueAtBegin">removeValueAtBegin</a>() and <a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a>().</p>
<!-- @@@canRemoveValueAtBegin -->
<!-- $$$canRemoveValueAtEnd[overload1]$$$canRemoveValueAtEnd -->
<h3 class="fn" id="canRemoveValueAtEnd"><span class="type">bool</span> QMetaSequence::<span class="name">canRemoveValueAtEnd</span>() const</h3>
<p>Returns <code>true</code> if values can be removed from the end of the container using <a href="qmetasequence.html#removeValue">removeValue</a>() can be placed at the, otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qmetasequence.html#removeValueAtEnd">removeValueAtEnd</a>() and <a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a>().</p>
<!-- @@@canRemoveValueAtEnd -->
<!-- $$$canSetValueAtIndex[overload1]$$$canSetValueAtIndex -->
<h3 class="fn" id="canSetValueAtIndex"><span class="type">bool</span> QMetaSequence::<span class="name">canSetValueAtIndex</span>() const</h3>
<p>Returns <code>true</code> if an value can be written to the container by index, otherwise <code>false</code>.</p>
<p><b>See also </b><a href="qmetasequence.html#setValueAtIndex">setValueAtIndex</a>().</p>
<!-- @@@canSetValueAtIndex -->
<!-- $$$canSetValueAtIterator[overload1]$$$canSetValueAtIterator -->
<h3 class="fn" id="canSetValueAtIterator"><span class="type">bool</span> QMetaSequence::<span class="name">canSetValueAtIterator</span>() const</h3>
<p>Returns <code>true</code> if the underlying container can write to the value pointed to by a non-const iterator, <code>false</code> otherwise.</p>
<p><b>See also </b><a href="qmetacontainer.html#hasIterator">hasIterator</a>() and <a href="qmetasequence.html#setValueAtIterator">setValueAtIterator</a>().</p>
<!-- @@@canSetValueAtIterator -->
<!-- $$$eraseRangeAtIterator[overload1]$$$eraseRangeAtIteratorvoid*constvoid*constvoid* -->
<h3 class="fn" id="eraseRangeAtIterator"><span class="type">void</span> QMetaSequence::<span class="name">eraseRangeAtIterator</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>iterator1</i>, const <span class="type">void</span> *<i>iterator2</i>) const</h3>
<p>Erases the range of values between the iterators <i>iterator1</i> and <i>iterator2</i> from the <i>container</i>, if possible.</p>
<p><b>See also </b><a href="qmetasequence.html#canEraseValueAtIterator">canEraseValueAtIterator</a>(), <a href="qmetacontainer.html#begin">begin</a>(), and <a href="qmetacontainer.html#end">end</a>().</p>
<!-- @@@eraseRangeAtIterator -->
<!-- $$$eraseValueAtIterator[overload1]$$$eraseValueAtIteratorvoid*constvoid* -->
<h3 class="fn" id="eraseValueAtIterator"><span class="type">void</span> QMetaSequence::<span class="name">eraseValueAtIterator</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>iterator</i>) const</h3>
<p>Erases the value pointed to by the non-const <i>iterator</i> from the <i>container</i>, if possible.</p>
<p><b>See also </b><a href="qmetasequence.html#canEraseValueAtIterator">canEraseValueAtIterator</a>(), <a href="qmetacontainer.html#begin">begin</a>(), and <a href="qmetacontainer.html#end">end</a>().</p>
<!-- @@@eraseValueAtIterator -->
<!-- $$$fromContainer[overload1]$$$fromContainer -->
<h3 class="fn" id="fromContainer"><code>[static, since 6.0] </code>template &lt;typename T&gt; <span class="type">QMetaSequence</span> QMetaSequence::<span class="name">fromContainer</span>()</h3>
<p>Returns the <a href="qmetasequence.html">QMetaSequence</a> corresponding to the type given as template parameter.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@fromContainer -->
<!-- $$$insertValueAtIterator[overload1]$$$insertValueAtIteratorvoid*constvoid*constvoid* -->
<h3 class="fn" id="insertValueAtIterator"><span class="type">void</span> QMetaSequence::<span class="name">insertValueAtIterator</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>iterator</i>, const <span class="type">void</span> *<i>value</i>) const</h3>
<p>Inserts <i>value</i> into the <i>container</i>, if possible, taking the non-const <i>iterator</i> into account. If <a href="qmetasequence.html#canInsertValueAtIterator">canInsertValueAtIterator</a>() returns <code>false</code>, the <i>value</i> is not inserted. Else if <a href="qmetasequence.html#isSortable">isSortable</a>() returns <code>true</code>, the value is inserted before the value pointed to by <i>iterator</i>. Else, the <i>value</i> is inserted at an unspecified place or not at all. In the latter case, the <i>iterator</i> is taken as a hint. If it points to the correct place for the <i>value</i>, the operation may be faster than a <a href="qmetasequence.html#addValue">addValue</a>() without iterator.</p>
<p><b>See also </b><a href="qmetasequence.html#canInsertValueAtIterator">canInsertValueAtIterator</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), <a href="qmetacontainer.html#begin">begin</a>(), and <a href="qmetacontainer.html#end">end</a>().</p>
<!-- @@@insertValueAtIterator -->
<!-- $$$isSortable[overload1]$$$isSortable -->
<h3 class="fn" id="isSortable"><span class="type">bool</span> QMetaSequence::<span class="name">isSortable</span>() const</h3>
<p>Returns <code>true</code> if the underlying container is sortable, otherwise returns <code>false</code>. A container is considered sortable if values added to it are placed in a defined location. Inserting into or adding to a sortable container will always succeed. Inserting into or adding to an unsortable container may not succeed, for example if the container is a <a href="qset.html">QSet</a> that already contains the value being inserted.</p>
<p><b>See also </b><a href="qmetasequence.html#addValue">addValue</a>(), <a href="qmetasequence.html#insertValueAtIterator">insertValueAtIterator</a>(), <a href="qmetasequence.html#canAddValueAtBegin">canAddValueAtBegin</a>(), <a href="qmetasequence.html#canAddValueAtEnd">canAddValueAtEnd</a>(), <a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a>(), and <a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a>().</p>
<!-- @@@isSortable -->
<!-- $$$removeValue[overload1]$$$removeValuevoid* -->
<h3 class="fn" id="removeValue"><span class="type">void</span> QMetaSequence::<span class="name">removeValue</span>(<span class="type">void</span> *<i>container</i>) const</h3>
<p>Removes an value from the <i>container</i> if possible. If <a href="qmetasequence.html#canRemoveValue">canRemoveValue</a>() returns <code>false</code>, no value is removed. Else, if <a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a>() returns <code>true</code>, the last value in the <i>container</i> is removed. Else, if <a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a>() returns <code>true</code>, the first value in the <i>container</i> is removed. Else, an unspecified value or nothing is removed.</p>
<p><b>See also </b><a href="qmetasequence.html#canRemoveValue">canRemoveValue</a>(), <a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a>(), <a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), and <a href="qmetasequence.html#addValue">addValue</a>().</p>
<!-- @@@removeValue -->
<!-- $$$removeValueAtBegin[overload1]$$$removeValueAtBeginvoid* -->
<h3 class="fn" id="removeValueAtBegin"><span class="type">void</span> QMetaSequence::<span class="name">removeValueAtBegin</span>(<span class="type">void</span> *<i>container</i>) const</h3>
<p>Removes a value from the beginning of <i>container</i> if possible. If <a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a>() returns <code>false</code>, the value is not removed.</p>
<p><b>See also </b><a href="qmetasequence.html#canRemoveValueAtBegin">canRemoveValueAtBegin</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), and <a href="qmetasequence.html#addValueAtBegin">addValueAtBegin</a>().</p>
<!-- @@@removeValueAtBegin -->
<!-- $$$removeValueAtEnd[overload1]$$$removeValueAtEndvoid* -->
<h3 class="fn" id="removeValueAtEnd"><span class="type">void</span> QMetaSequence::<span class="name">removeValueAtEnd</span>(<span class="type">void</span> *<i>container</i>) const</h3>
<p>Removes a value from the end of <i>container</i> if possible. If <a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a>() returns <code>false</code>, the value is not removed.</p>
<p><b>See also </b><a href="qmetasequence.html#canRemoveValueAtEnd">canRemoveValueAtEnd</a>(), <a href="qmetasequence.html#isSortable">isSortable</a>(), and <a href="qmetasequence.html#addValueAtEnd">addValueAtEnd</a>().</p>
<!-- @@@removeValueAtEnd -->
<!-- $$$setValueAtIndex[overload1]$$$setValueAtIndexvoid*qsizetypeconstvoid* -->
<h3 class="fn" id="setValueAtIndex"><span class="type">void</span> QMetaSequence::<span class="name">setValueAtIndex</span>(<span class="type">void</span> *<i>container</i>, <span class="type">qsizetype</span> <i>index</i>, const <span class="type">void</span> *<i>value</i>) const</h3>
<p>Overwrites the value at <i>index</i> in the <i>container</i> using the <i>value</i> passed as parameter if that is possible.</p>
<p><b>See also </b><a href="qmetasequence.html#valueAtIndex">valueAtIndex</a>() and <a href="qmetasequence.html#canSetValueAtIndex">canSetValueAtIndex</a>().</p>
<!-- @@@setValueAtIndex -->
<!-- $$$setValueAtIterator[overload1]$$$setValueAtIteratorconstvoid*constvoid* -->
<h3 class="fn" id="setValueAtIterator"><span class="type">void</span> QMetaSequence::<span class="name">setValueAtIterator</span>(const <span class="type">void</span> *<i>iterator</i>, const <span class="type">void</span> *<i>value</i>) const</h3>
<p>Writes <i>value</i> to the value pointed to by the non-const <i>iterator</i>, if possible.</p>
<p><b>See also </b><a href="qmetasequence.html#valueAtIterator">valueAtIterator</a>(), <a href="qmetasequence.html#canSetValueAtIterator">canSetValueAtIterator</a>(), <a href="qmetacontainer.html#begin">begin</a>(), and <a href="qmetacontainer.html#end">end</a>().</p>
<!-- @@@setValueAtIterator -->
<!-- $$$valueAtConstIterator[overload1]$$$valueAtConstIteratorconstvoid*void* -->
<h3 class="fn" id="valueAtConstIterator"><span class="type">void</span> QMetaSequence::<span class="name">valueAtConstIterator</span>(const <span class="type">void</span> *<i>iterator</i>, <span class="type">void</span> *<i>result</i>) const</h3>
<p>Retrieves the value pointed to by the const <i>iterator</i> and stores it in the memory location pointed to by <i>result</i>, if possible.</p>
<p><b>See also </b><a href="qmetasequence.html#canGetValueAtConstIterator">canGetValueAtConstIterator</a>(), <a href="qmetacontainer.html#constBegin">constBegin</a>(), and <a href="qmetacontainer.html#constEnd">constEnd</a>().</p>
<!-- @@@valueAtConstIterator -->
<!-- $$$valueAtIndex[overload1]$$$valueAtIndexconstvoid*qsizetypevoid* -->
<h3 class="fn" id="valueAtIndex"><span class="type">void</span> QMetaSequence::<span class="name">valueAtIndex</span>(const <span class="type">void</span> *<i>container</i>, <span class="type">qsizetype</span> <i>index</i>, <span class="type">void</span> *<i>result</i>) const</h3>
<p>Retrieves the value at <i>index</i> in the <i>container</i> and places it in the memory location pointed to by <i>result</i>, if that is possible.</p>
<p><b>See also </b><a href="qmetasequence.html#setValueAtIndex">setValueAtIndex</a>() and <a href="qmetasequence.html#canGetValueAtIndex">canGetValueAtIndex</a>().</p>
<!-- @@@valueAtIndex -->
<!-- $$$valueAtIterator[overload1]$$$valueAtIteratorconstvoid*void* -->
<h3 class="fn" id="valueAtIterator"><span class="type">void</span> QMetaSequence::<span class="name">valueAtIterator</span>(const <span class="type">void</span> *<i>iterator</i>, <span class="type">void</span> *<i>result</i>) const</h3>
<p>Retrieves the value pointed to by the non-const <i>iterator</i> and stores it in the memory location pointed to by <i>result</i>, if possible.</p>
<p><b>See also </b><a href="qmetasequence.html#setValueAtIterator">setValueAtIterator</a>(), <a href="qmetasequence.html#canGetValueAtIterator">canGetValueAtIterator</a>(), <a href="qmetacontainer.html#begin">begin</a>(), and <a href="qmetacontainer.html#end">end</a>().</p>
<!-- @@@valueAtIterator -->
<!-- $$$valueMetaType[overload1]$$$valueMetaType -->
<h3 class="fn" id="valueMetaType"><span class="type"><a href="qmetatype.html">QMetaType</a></span> QMetaSequence::<span class="name">valueMetaType</span>() const</h3>
<p>Returns the meta type for values stored in the container.</p>
<!-- @@@valueMetaType -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
