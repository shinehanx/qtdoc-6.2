<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qproperty.cpp -->
  <title>QProperty Class | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html">C++ Classes</a></li>
<li>QProperty</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QProperty Class</h1>
<span class="small-subtitle">template &lt;typename T&gt; class QProperty</span>
<!-- $$$QProperty-brief -->
<p>The QProperty class is a template class that enables automatic property bindings. <a href="#details">More...</a></p>
<!-- @@@QProperty -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QProperty&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qpropertydata.html">QPropertyData</a></td></tr></table></div>
<ul>
<li><a href="qproperty-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-8">QProperty</a></b>(T &amp;&amp;<i>initialValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-7">QProperty</a></b>(const T &amp;<i>initialValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-4">QProperty</a></b>(Functor &amp;&amp;<i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty-3">QProperty</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>binding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#QProperty">QProperty</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#operator-eq-4">operator=</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#dtor.QProperty">~QProperty</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyNotifier </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#addNotifier">addNotifier</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#binding">binding</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#onValueChanged">onValueChanged</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setBinding">setBinding</a></b>(const QPropertyBinding&lt;T&gt; &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setBinding-1">setBinding</a></b>(const QUntypedPropertyBinding &amp;<i>newBinding</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setBinding-2">setBinding</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setValue">setValue</a></b>(QProperty::rvalue_ref <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#setValue-1">setValue</a></b>(QProperty::parameter_type <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyChangeHandler&lt;Functor&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#subscribe">subscribe</a></b>(Functor <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPropertyBinding&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#takeBinding">takeBinding</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty::parameter_type </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#value">value</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#operator-eq">operator=</a></b>(QProperty::rvalue_ref <i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QProperty&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#operator-eq-1">operator=</a></b>(QProperty::parameter_type <i>newValue</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#beginPropertyUpdateGroup">beginPropertyUpdateGroup</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qproperty.html#endPropertyUpdateGroup">endPropertyUpdateGroup</a></b>()</td></tr>
</table></div>
<!-- $$$QProperty-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QProperty&lt;T&gt; is one of the classes implementing <a href="bindableproperties.html">Qt Bindable Properties</a>. It is a container that holds an instance of T. You can assign a value to it and you can read it via the <a href="qproperty.html#value">value</a>() function or the T conversion operator. You can also tie the property to an expression that computes the value dynamically, the binding expression. It is represented as a C++ lambda and can be used to express relationships between different properties in your application.</p>
</div>
<!-- @@@QProperty -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="operator-eq-1"><span class="type"><a href="qproperty.html#QProperty">QProperty</a></span>&lt;<span class="type">T</span>&gt; &amp;QProperty::<span class="name">operator=</span>(<span class="type">QProperty::parameter_type</span> <i>newValue</i>)</h3><h3 class="fn fngroupitem" id="operator-eq"><span class="type"><a href="qproperty.html#QProperty">QProperty</a></span>&lt;<span class="type">T</span>&gt; &amp;QProperty::<span class="name">operator=</span>(<span class="type">QProperty::rvalue_ref</span> <i>newValue</i>)</h3></div>
<p>Assigns <i>newValue</i> to this property and returns a reference to this <a href="qproperty.html">QProperty</a>.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="setValue-1"><span class="type">void</span> QProperty::<span class="name">setValue</span>(<span class="type">QProperty::parameter_type</span> <i>newValue</i>)</h3><h3 class="fn fngroupitem" id="setValue"><span class="type">void</span> QProperty::<span class="name">setValue</span>(<span class="type">QProperty::rvalue_ref</span> <i>newValue</i>)</h3></div>
<p>Assigns <i>newValue</i> to this property and removes the property's associated binding, if present.</p>
<!-- @@@ -->
<!-- $$$QProperty$$$QPropertyT&& -->
<h3 class="fn" id="QProperty-8"><code>[default] </code>QProperty::<span class="name">QProperty</span>(<span class="type">T</span> &amp;&amp;<i>initialValue</i>)</h3>
<p>Move-Constructs a property with the provided <i>initialValue</i>.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyconstT& -->
<h3 class="fn" id="QProperty-7"><code>[default] </code>QProperty::<span class="name">QProperty</span>(const <span class="type">T</span> &amp;<i>initialValue</i>)</h3>
<p>Constructs a property with the provided <i>initialValue</i>.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyFunctor&& -->
<h3 class="fn" id="QProperty-4">template &lt;typename Functor&gt; QProperty::<span class="name">QProperty</span>(<span class="type">Functor</span> &amp;&amp;<i>f</i>)</h3>
<p>Constructs a property that is tied to the provided binding expression <i>f</i>. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty$$$QPropertyconstQPropertyBinding<T>& -->
<h3 class="fn" id="QProperty-3">QProperty::<span class="name">QProperty</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>binding</i>)</h3>
<p>Constructs a property that is tied to the provided <i>binding</i> expression. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>
<!-- @@@QProperty -->
<!-- $$$QProperty[overload1]$$$QProperty -->
<h3 class="fn" id="QProperty">QProperty::<span class="name">QProperty</span>()</h3>
<p>Constructs a property with a default constructed instance of T.</p>
<!-- @@@QProperty -->
<!-- $$$operator=$$$operator=constQPropertyBinding<T>& -->
<h3 class="fn" id="operator-eq-4"><code>[default] </code><span class="type"><a href="qproperty.html#QProperty">QProperty</a></span>&lt;<span class="type">T</span>&gt; &amp;QProperty::<span class="name">operator=</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>newBinding</i>)</h3>
<p>Associates the value of this property with the provided <i>newBinding</i> expression and returns a reference to this property. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>
<!-- @@@operator= -->
<!-- $$$~QProperty[overload1]$$$~QProperty -->
<h3 class="fn" id="dtor.QProperty">QProperty::<span class="name">~QProperty</span>()</h3>
<p>Destroys the property.</p>
<!-- @@@~QProperty -->
<!-- $$$addNotifier[overload1]$$$addNotifierFunctor -->
<h3 class="fn" id="addNotifier">template &lt;typename Functor&gt; <span class="type"><a href="qpropertynotifier.html">QPropertyNotifier</a></span> QProperty::<span class="name">addNotifier</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Subscribes the given functor <i>f</i> as a callback that is called whenever the value of the property changes.</p>
<p>The callback <i>f</i> is expected to be a type that has a plain call operator () without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>
<p>This method is in some cases easier to use than <a href="qproperty.html#onValueChanged">onValueChanged</a>(), as the returned object is not a template. It can therefore more easily be stored, e.g&#x2e; as a member in a class.</p>
<p><b>See also </b><a href="qproperty.html#onValueChanged">onValueChanged</a>() and <a href="qproperty.html#subscribe">subscribe</a>().</p>
<!-- @@@addNotifier -->
<!-- $$$binding[overload1]$$$binding -->
<h3 class="fn" id="binding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">binding</span>() const</h3>
<p>Returns the binding expression that is associated with this property. A default constructed QPropertyBinding&lt;T&gt; will be returned if no such association exists.</p>
<p><b>See also </b><a href="qproperty.html#setBinding">setBinding</a>().</p>
<!-- @@@binding -->
<!-- $$$onValueChanged[overload1]$$$onValueChangedFunctor -->
<h3 class="fn" id="onValueChanged">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler.html">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QProperty::<span class="name">onValueChanged</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Registers the given functor <i>f</i> as a callback that shall be called whenever the value of the property changes. On each value change, the handler is either called immediately, or deferred, depending on the context.</p>
<p>The callback <i>f</i> is expected to be a type that has a plain call operator () without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the registration. When it goes out of scope, the callback is de-registered.</p>
<!-- @@@onValueChanged -->
<!-- $$$setBinding[overload1]$$$setBindingconstQPropertyBinding<T>& -->
<h3 class="fn" id="setBinding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">setBinding</span>(const <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; &amp;<i>newBinding</i>)</h3>
<p>Associates the value of this property with the provided <i>newBinding</i> expression and returns the previously associated binding. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>
<p><b>See also </b><a href="qproperty.html#binding">binding</a>().</p>
<!-- @@@setBinding -->
<!-- $$$setBinding$$$setBindingconstQUntypedPropertyBinding& -->
<h3 class="fn" id="setBinding-1"><span class="type">bool</span> QProperty::<span class="name">setBinding</span>(const <span class="type">QUntypedPropertyBinding</span> &amp;<i>newBinding</i>)</h3>
<p>This is an overloaded function.</p>
<p>Associates the value of this property with the provided <i>newBinding</i> expression. The first time the property value is read, the binding is evaluated. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>
<p>Returns true if the type of this property is the same as the type the binding function returns; false otherwise.</p>
<!-- @@@setBinding -->
<!-- $$$setBinding$$$setBindingFunctor -->
<h3 class="fn" id="setBinding-2">template &lt;typename Functor&gt; <span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">setBinding</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>This is an overloaded function.</p>
<p>Associates the value of this property with the provided functor <i>f</i> and returns the previously associated binding. The first time the property value is read, the binding is evaluated by invoking the call operator () of <i>f</i>. Whenever a dependency of the binding changes, the binding will be re-evaluated the next time the value of this property is read.</p>
<p><b>See also </b><a href="bindableproperties.html#formulating-a-property-binding">Formulating a Property Binding</a>.</p>
<!-- @@@setBinding -->
<!-- $$$subscribe[overload1]$$$subscribeFunctor -->
<h3 class="fn" id="subscribe">template &lt;typename Functor&gt; <span class="type"><a href="qpropertychangehandler.html">QPropertyChangeHandler</a></span>&lt;<span class="type">Functor</span>&gt; QProperty::<span class="name">subscribe</span>(<span class="type">Functor</span> <i>f</i>)</h3>
<p>Subscribes the given functor <i>f</i> as a callback that is called immediately and whenever the value of the property changes in the future. On each value change, the handler is either called immediately, or deferred, depending on the context.</p>
<p>The callback <i>f</i> is expected to be a type that can be copied and has a plain call operator() without any parameters. This means that you can provide a C++ lambda expression, a std::function or even a custom struct with a call operator.</p>
<p>The returned property change handler object keeps track of the subscription. When it goes out of scope, the callback is unsubscribed.</p>
<!-- @@@subscribe -->
<!-- $$$takeBinding[overload1]$$$takeBinding -->
<h3 class="fn" id="takeBinding"><span class="type">QPropertyBinding</span>&lt;<span class="type">T</span>&gt; QProperty::<span class="name">takeBinding</span>()</h3>
<p>Disassociates the binding expression from this property and returns it. After calling this function, the value of the property will only change if you assign a new value to it, or when a new binding is set.</p>
<!-- @@@takeBinding -->
<!-- $$$value[overload1]$$$value -->
<h3 class="fn" id="value"><span class="type">QProperty::parameter_type</span> QProperty::<span class="name">value</span>() const</h3>
<p>Returns the value of the property. This may evaluate a binding expression that is tied to this property, before returning the value.</p>
<p><b>See also </b><a href="qproperty.html#setValue">setValue</a>().</p>
<!-- @@@value -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$beginPropertyUpdateGroup[overload1]$$$beginPropertyUpdateGroup -->
<h3 class="fn" id="beginPropertyUpdateGroup"><code>[since 6.2] </code><span class="type">void</span> <span class="name">beginPropertyUpdateGroup</span>()</h3>
<p>Marks the beginning of a property update group. Inside this group, changing a property does neither immediately update any dependent properties nor does it trigger change notifications. Those are instead deferred until the group is ended by a call to <a href="qproperty.html#endPropertyUpdateGroup">endPropertyUpdateGroup</a>.</p>
<p>Groups can be nested. In that case, the deferral ends only after the outermost group has been ended.</p>
<div class="admonition note">
<p><b>Note: </b>Change notifications are only send after all property values affected by the group have been updated to their new values. This allows re-establishing a class invariant if multiple properties need to be updated, preventing any external observer from noticing an inconsistent state.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qproperty.html#endPropertyUpdateGroup">Qt::endPropertyUpdateGroup</a>.</p>
<!-- @@@beginPropertyUpdateGroup -->
<!-- $$$endPropertyUpdateGroup[overload1]$$$endPropertyUpdateGroup -->
<h3 class="fn" id="endPropertyUpdateGroup"><code>[since 6.2] </code><span class="type">void</span> <span class="name">endPropertyUpdateGroup</span>()</h3>
<p>Ends a property update group. If the outermost group has been ended, and deferred binding evaluations and notifications happen now.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling endPropertyUpdateGroup without a preceding call to <a href="qproperty.html#beginPropertyUpdateGroup">beginPropertyUpdateGroup</a> results in undefined behavior.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qproperty.html#beginPropertyUpdateGroup">Qt::beginPropertyUpdateGroup</a>.</p>
<!-- @@@endPropertyUpdateGroup -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
