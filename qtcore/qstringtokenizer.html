<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qstringtokenizer.cpp -->
  <title>QStringTokenizer Class | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html">C++ Classes</a></li>
<li>QStringTokenizer</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#lazy-sequences">Lazy Sequences</a></li>
<li class="level2"><a href="#end-sentinel">End Sentinel</a></li>
<li class="level2"><a href="#temporaries">Temporaries</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QStringTokenizer Class</h1>
<span class="small-subtitle">template &lt;typename Haystack, typename Needle&gt; class QStringTokenizer</span>
<!-- $$$QStringTokenizer-brief -->
<p>The QStringTokenizer class splits strings into tokens along given separators. <a href="#details">More...</a></p>
<!-- @@@QStringTokenizer -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QStringTokenizer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> QtPrivate::Tok::HaystackPinning (private), QtPrivate::Tok::NeedlePinning (private), and </td></tr></table></div>
<ul>
<li><a href="qstringtokenizer-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qdoc/17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_iterator-typedef">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_pointer-typedef">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#const_reference-typedef">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#difference_type-typedef">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#iterator-typedef">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#pointer-typedef">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#reference-typedef">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#sentinel-typedef">sentinel</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#size_type-typedef">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#value_type-typedef">value_type</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#QStringTokenizer-1">QStringTokenizer</a></b>(Haystack <i>haystack</i>, Needle <i>needle</i>, Qt::SplitBehavior <i>sb</i> = Qt::KeepEmptyParts, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></b>(Haystack <i>haystack</i>, Needle <i>needle</i>, Qt::CaseSensitivity <i>cs</i>, Qt::SplitBehavior <i>sb</i> = Qt::KeepEmptyParts)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#begin">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer::iterator </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer::sentinel </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringTokenizer::sentinel </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#end">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> LContainer </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#toContainer">toContainer</a></b>(LContainer &amp;&amp;<i>c</i> = {}) const &</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> RContainer </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#toContainer-1">toContainer</a></b>(RContainer &amp;&amp;<i>c</i> = {}) const &&</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> decltype(QtPrivate::Tok::TokenizerResult&lt;Haystack, Needle&gt;({std::forward&lt;Haystack&gt;(h), std::forward&lt;Needle&gt;(n), flags...})) </td><td class="memItemRight bottomAlign"><b><a href="qstringtokenizer.html#qTokenize">qTokenize</a></b>(Haystack &amp;&amp;<i>haystack</i>, Needle &amp;&amp;<i>needle</i>, Flags... <i>flags</i>)</td></tr>
</table></div>
<!-- $$$QStringTokenizer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Splits a string into substrings wherever a given separator occurs, returning a (lazily constructed) list of those strings. If the separator does not match anywhere in the string, produces a single-element list containing this string. If the separator is empty, QStringTokenizer produces an empty string, followed by each of the string's characters, followed by another empty string. The two enumerations <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> and <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> further control the output.</p>
<p>QStringTokenizer drives <a href="qstringview.html#tokenize">QStringView::tokenize</a>(), but, at least with a recent compiler, you can use it directly, too:</p>
<pre class="cpp">
 <span class="keyword">for</span> (<span class="keyword">auto</span> it : <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{string<span class="operator">,</span> separator})
     use(<span class="operator">*</span>it);
</pre>
<div class="admonition note">
<p><b>Note: </b>You should never, ever, name the template arguments of a QStringTokenizer explicitly. If you can use C++17 Class Template Argument Deduction (CTAD), you may write <code>QStringTokenizer{string, separator}</code> (without template arguments). If you can't use C++17 CTAD, you must use the <a href="qstringview.html#split">QStringView::split</a>() or QLatin1String::split() member functions and store the return value only in <code>auto</code> variables:</p>
</div>
<pre class="cpp">
 <span class="keyword">auto</span> result <span class="operator">=</span> string<span class="operator">.</span>split(sep);
</pre>
<p>This is because the template arguments of QStringTokenizer have a very subtle dependency on the specific string and separator types from with which they are constructed, and they don't usually correspond to the actual types passed.</p>
<h3 id="lazy-sequences">Lazy Sequences</h3>
<p>QStringTokenizer acts as a so-called lazy sequence, that is, each next element is only computed once you ask for it. Lazy sequences have the advantage that they only require O(1) memory. They have the disadvantage that, at least for QStringTokenizer, they only allow forward, not random-access, iteration.</p>
<p>The intended use-case is that you just plug it into a ranged for loop:</p>
<pre class="cpp">
 <span class="keyword">for</span> (<span class="keyword">auto</span> it : <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{string<span class="operator">,</span> separator})
     use(<span class="operator">*</span>it);
</pre>
<p>or a C++20 ranged algorithm:</p>
<pre class="cpp">
 std<span class="operator">::</span>ranges<span class="operator">::</span>for_each(<span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{string<span class="operator">,</span> separator}<span class="operator">,</span>
                       <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">auto</span> token) { use(token); });
</pre>
<h3 id="end-sentinel">End Sentinel</h3>
<p>The QStringTokenizer iterators cannot be used with classical STL algorithms, because those require iterator/iterator pairs, while QStringTokenizer uses sentinels. That is, it uses a different type, QStringTokenizer::sentinel, to mark the end of the range. This improves performance, because the sentinel is an empty type. Sentinels are supported from C++17 (for ranged for) and C++20 (for algorithms using the new ranges library).</p>
<h3 id="temporaries">Temporaries</h3>
<p>QStringTokenizer is very carefully designed to avoid dangling references. If you construct a tokenizer from a temporary string (an rvalue), that argument is stored internally, so the referenced data isn't deleted before it is tokenized:</p>
<pre class="cpp">
 <span class="keyword">auto</span> tok <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{widget<span class="operator">.</span>text()<span class="operator">,</span> u<span class="char">','</span>};
 <span class="comment">// return value of `widget.text()` is destroyed, but content was moved into `tok`</span>
 <span class="keyword">for</span> (<span class="keyword">auto</span> e : tok)
    use(e);
</pre>
<p>If you pass named objects (lvalues), then QStringTokenizer does not store a copy. You are responsible to keep the named object's data around for longer than the tokenizer operates on it:</p>
<pre class="cpp">
 <span class="keyword">auto</span> text <span class="operator">=</span> widget<span class="operator">.</span>text();
 <span class="keyword">auto</span> tok <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{text<span class="operator">,</span> u<span class="char">','</span>};
 text<span class="operator">.</span>clear();      <span class="comment">// destroy content of `text`</span>
 <span class="keyword">for</span> (<span class="keyword">auto</span> e : tok) <span class="comment">// ERROR: `tok` references deleted data!</span>
     use(e);
</pre>
</div>
<p><b>See also </b><a href="qstringview.html#split">QStringView::split</a>(), <a href="qstring.html#split">QString::split</a>(), and <a href="qregularexpression.html">QRegularExpression</a>.</p>
<!-- @@@QStringTokenizer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">const_iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qstringtokenizer.html">QStringTokenizer</a>.</p>
<p><b>See also </b><a href="qstringtokenizer.html#iterator-typedef">iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" id="const_pointer-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">const_pointer</span></h3>
<p>Alias for <code>value_type *</code>.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" id="const_reference-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">const_reference</span></h3>
<p>Alias for <code>value_type &amp;</code>.</p>
<!-- @@@const_reference -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">difference_type</span></h3>
<p>Alias for qsizetype.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qstringtokenizer.html">QStringTokenizer</a>.</p>
<p><a href="qstringtokenizer.html">QStringTokenizer</a> does not support mutable iterators, so this is the same as const_iterator.</p>
<p><b>See also </b><a href="qstringtokenizer.html#const_iterator-typedef">const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" id="pointer-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">pointer</span></h3>
<p>Alias for <code>value_type *</code>.</p>
<p><a href="qstringtokenizer.html">QStringTokenizer</a> does not support mutable iterators, so this is the same as const_pointer.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" id="reference-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">reference</span></h3>
<p>Alias for <code>value_type &amp;</code>.</p>
<p><a href="qstringtokenizer.html">QStringTokenizer</a> does not support mutable references, so this is the same as const_reference.</p>
<!-- @@@reference -->
<!-- $$$sentinel -->
<h3 class="fn" id="sentinel-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">sentinel</span></h3>
<p>This typedef provides an STL-style sentinel for QStringTokenizer::iterator and QStringTokenizer::const_iterator.</p>
<p><b>See also </b><a href="qstringtokenizer.html#const_iterator-typedef">const_iterator</a>.</p>
<!-- @@@sentinel -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">size_type</span></h3>
<p>Alias for qsizetype.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef"><code>[alias] </code>QStringTokenizer::<span class="name">value_type</span></h3>
<p>Alias for <code>const QStringView</code> or <code>const QLatin1String</code>, depending on the tokenizer's <code>Haystack</code> template argument.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="begin"><span class="type">QStringTokenizer::iterator</span> QStringTokenizer::<span class="name">begin</span>() const</h3><h3 class="fn fngroupitem" id="cbegin"><span class="type">QStringTokenizer::iterator</span> QStringTokenizer::<span class="name">cbegin</span>() const</h3></div>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first token in the list.</p>
<p><b>See also </b><a href="qstringtokenizer.html#end">end</a>() and <a href="qstringtokenizer.html#cend">cend</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="QStringTokenizer">QStringTokenizer::<span class="name">QStringTokenizer</span>(<span class="type">Haystack</span> <i>haystack</i>, <span class="type">Needle</span> <i>needle</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a></span> <i>sb</i> = Qt::KeepEmptyParts)</h3><h3 class="fn fngroupitem" id="QStringTokenizer-1">QStringTokenizer::<span class="name">QStringTokenizer</span>(<span class="type">Haystack</span> <i>haystack</i>, <span class="type">Needle</span> <i>needle</i>, <span class="type"><a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a></span> <i>sb</i> = Qt::KeepEmptyParts, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive)</h3></div>
<p>Constructs a string tokenizer that splits the string <i>haystack</i> into substrings wherever <i>needle</i> occurs, and allows iteration over those strings as they are found. If <i>needle</i> does not match anywhere in <i>haystack</i>, a single element containing <i>haystack</i> is produced.</p>
<p><i>cs</i> specifies whether <i>needle</i> should be matched case sensitively or case insensitively.</p>
<p>If <i>sb</i> is <a href="qt.html#SplitBehaviorFlags-enum">Qt::SkipEmptyParts</a>, empty entries don't appear in the result. By default, empty entries are included.</p>
<p><b>See also </b><a href="qstringview.html#split">QStringView::split</a>(), <a href="qstring.html#split">QString::split</a>(), <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a>, and <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a>.</p>
<!-- @@@ -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><span class="type">QStringTokenizer::sentinel</span> QStringTokenizer::<span class="name">cend</span>() const</h3>
<p>Same as <a href="qstringtokenizer.html#end">end</a>().</p>
<p><b>See also </b><a href="qstringtokenizer.html#cbegin">cbegin</a>() and <a href="qstringtokenizer.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><span class="type">QStringTokenizer::sentinel</span> QStringTokenizer::<span class="name">end</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style sentinel</a> pointing to the imaginary token after the last token in the list.</p>
<p><b>See also </b><a href="qstringtokenizer.html#begin">begin</a>() and <a href="qstringtokenizer.html#cend">cend</a>().</p>
<!-- @@@end -->
<!-- $$$toContainer[overload1]$$$toContainerLContainer&& -->
<h3 class="fn" id="toContainer">template &lt;typename LContainer&gt; <span class="type">LContainer</span> QStringTokenizer::<span class="name">toContainer</span>(<span class="type">LContainer</span> &amp;&amp;<i>c</i> = {}) const &</h3>
<p>Converts the lazy sequence into a (typically) random-access container of type <code>LContainer</code>.</p>
<p>This function is only available if <code>Container</code> has a <code>value_type</code> matching this tokenizer's value_type.</p>
<p>If you pass in a named container (an lvalue) for <i>c</i>, then that container is filled, and a reference to it is returned. If you pass in a temporary container (an rvalue, incl. the default argument), then that container is filled, and returned by value.</p>
<pre class="cpp">
 <span class="comment">// assuming tok's value_type is QStringView, then...</span>
 <span class="keyword">auto</span> tok <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{<span class="operator">~</span><span class="operator">~</span><span class="operator">~</span>};
 <span class="comment">// ... rac1 is a QList:</span>
 <span class="keyword">auto</span> rac1 <span class="operator">=</span> tok<span class="operator">.</span>toContainer();
 <span class="comment">// ... rac2 is std::pmr::vector&lt;QStringView&gt;:</span>
 <span class="keyword">auto</span> rac2 <span class="operator">=</span> tok<span class="operator">.</span>toContainer<span class="operator">&lt;</span>std<span class="operator">::</span>pmr<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type"><a href="qstringview.html">QStringView</a></span><span class="operator">&gt;</span><span class="operator">&gt;</span>();
 <span class="keyword">auto</span> rac3 <span class="operator">=</span> <span class="type"><a href="qvarlengtharray.html">QVarLengthArray</a></span><span class="operator">&lt;</span><span class="type"><a href="qstringview.html">QStringView</a></span><span class="operator">,</span> <span class="number">12</span><span class="operator">&gt;</span>{};
 <span class="comment">// appends the token sequence produced by tok to rac3</span>
 <span class="comment">//  and returns a reference to rac3 (which we ignore here):</span>
 tok<span class="operator">.</span>toContainer(rac3);
</pre>
<p>This gives you maximum flexibility in how you want the sequence to be stored.</p>
<!-- @@@toContainer -->
<!-- $$$toContainer$$$toContainerRContainer&& -->
<h3 class="fn" id="toContainer-1">template &lt;typename RContainer&gt; <span class="type">RContainer</span> QStringTokenizer::<span class="name">toContainer</span>(<span class="type">RContainer</span> &amp;&amp;<i>c</i> = {}) const &&</h3>
<p>This is an overloaded function.</p>
<p>Converts the lazy sequence into a (typically) random-access container of type <code>RContainer</code>.</p>
<p>In addition to the constraints on the lvalue-this overload, this rvalue-this overload is only available when this <a href="qstringtokenizer.html">QStringTokenizer</a> does not store the haystack internally, as this could create a container full of dangling references:</p>
<pre class="cpp">
 <span class="keyword">auto</span> tokens <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{widget<span class="operator">.</span>text()<span class="operator">,</span> u<span class="char">','</span>}<span class="operator">.</span>toContainer();
 <span class="comment">// ERROR: cannot call toContainer() on rvalue</span>
 <span class="comment">// 'tokens' references the data of the copy of widget.text()</span>
 <span class="comment">// stored inside the QStringTokenizer, which has since been deleted</span>
</pre>
<p>To fix, store the <a href="qstringtokenizer.html">QStringTokenizer</a> in a temporary:</p>
<pre class="cpp">
 <span class="keyword">auto</span> tokenizer <span class="operator">=</span> <span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{widget<span class="operator">.</span>text90<span class="operator">,</span> u<span class="char">','</span>};
 <span class="keyword">auto</span> tokens <span class="operator">=</span> tokenizer<span class="operator">.</span>toContainer();
 <span class="comment">// OK: the copy of widget.text() stored in 'tokenizer' keeps the data</span>
 <span class="comment">// referenced by 'tokens' alive.</span>
</pre>
<p>You can force this function into existence by passing a view instead:</p>
<pre class="cpp">
 func(<span class="type"><a href="qstringtokenizer.html#QStringTokenizer">QStringTokenizer</a></span>{<span class="type"><a href="qstringview.html">QStringView</a></span>{widget<span class="operator">.</span>text()}<span class="operator">,</span> u<span class="char">','</span>}<span class="operator">.</span>toContainer());
 <span class="comment">// OK: compiler keeps widget.text() around until after func() has executed</span>
</pre>
<p>If you pass in a named container (an lvalue)for <i>c</i>, then that container is filled, and a reference to it is returned. If you pass in a temporary container (an rvalue, incl. the default argument), then that container is filled, and returned by value.</p>
<!-- @@@toContainer -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qTokenize[overload1]$$$qTokenizeHaystack&&Needle&&Flags... -->
<h3 class="fn" id="qTokenize"><code>[since 6.0] </code>template &lt;typename Haystack, typename Needle, typename Flags&gt; <span class="type">decltype</span>(<span class="type">QtPrivate::Tok::TokenizerResult</span>&lt;<span class="type">Haystack</span>, <span class="type">Needle</span>&gt;({<span class="type">std::forward</span>&lt;<span class="type">Haystack</span>&gt;(<span class="type">h</span>), <span class="type">std::forward</span>&lt;<span class="type">Needle</span>&gt;(<span class="type">n</span>), <span class="type">flags</span>...})) <span class="name">qTokenize</span>(<span class="type">Haystack</span> &amp;&amp;<i>haystack</i>, <span class="type">Needle</span> &amp;&amp;<i>needle</i>, <span class="type">Flags</span>... <i>flags</i>)</h3>
<p>Factory function for a <a href="qstringtokenizer.html">QStringTokenizer</a> that splits the string <i>haystack</i> into substrings wherever <i>needle</i> occurs, and allows iteration over those strings as they are found. If <i>needle</i> does not match anywhere in <i>haystack</i>, a single element containing <i>haystack</i> is produced.</p>
<p>Pass values from <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> and <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> enumerators as <i>flags</i> to modify the behavior of the tokenizer.</p>
<p>You can use this function if your compiler doesn't, yet, support C++17 Class Template Argument Deduction (CTAD). We recommend direct use of <a href="qstringtokenizer.html">QStringTokenizer</a> with CTAD instead.</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@qTokenize -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
