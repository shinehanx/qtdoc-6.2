<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qfuture.qdoc -->
  <title>QtFuture Namespace | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li>QtFuture Namespace</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#types">Types</a></li>
<li class="level1"><a href="#functions">Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QtFuture Namespace</h1>
<!-- $$$QtFuture-brief -->
<p>Contains miscellaneous identifiers used by the <a href="qfuture.html">QFuture</a> class. <a href="#details">More...</a></p>
<!-- @@@QtFuture -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;<a href="qfuture.html">QFuture</a>&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div>
<h2 id="types">Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#Launch-enum">Launch</a></b> { Sync, Async, Inherit }</td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;ArgsType&lt;Signal&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#connect">connect</a></b>(Sender *<i>sender</i>, Signal <i>signal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeExceptionalFuture">makeExceptionalFuture</a></b>(const QException &amp;<i>exception</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeExceptionalFuture-1">makeExceptionalFuture</a></b>(std::exception_ptr <i>exception</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;std::decay_t&lt;T&gt;&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyFuture">makeReadyFuture</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;void&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyFuture-1">makeReadyFuture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtfuture.html#makeReadyFuture-2">makeReadyFuture</a></b>(const QList&lt;T&gt; &amp;<i>values</i>)</td></tr>
</table></div>
<!-- $$$QtFuture-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
</div>
<!-- @@@QtFuture -->
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$Launch$$$Sync$$$Async$$$Inherit -->
<h3 class="fn" id="Launch-enum"><code>[since 6.0] </code>enum class QtFuture::<span class="name">Launch</span></h3>
<p>Represents execution policies for running a <a href="qfuture.html">QFuture</a> continuation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QtFuture::Launch::Sync</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The continuation will be launched in the same thread that fulfills the promise associated with the future to which the continuation was attached, or if it has already finished, the continuation will be invoked immediately, in the thread that executes <code>then()</code>.</td></tr>
<tr><td class="topAlign"><code>QtFuture::Launch::Async</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">The continuation will be launched in a separate thread taken from the global <a href="qthreadpool.html">QThreadPool</a>.</td></tr>
<tr><td class="topAlign"><code>QtFuture::Launch::Inherit</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">The continuation will inherit the launch policy or thread pool of the future to which it is attached.</td></tr>
</table></div>
<p><code>Sync</code> is used as a default launch policy.</p>
<p>This enum was introduced or modified in Qt 6.0.</p>
<p><b>See also </b><a href="qfuture.html#then">QFuture::then</a>() and <a href="qthreadpool.html#globalInstance">QThreadPool::globalInstance</a>().</p>
<!-- @@@Launch -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$connect[overload1]$$$connectSender*Signal -->
<h3 class="fn" id="connect">template &lt;typename Sender, typename Signal, typename&gt; <span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">ArgsType</span>&lt;<span class="type">Signal</span>&gt;&gt; QtFuture::<span class="name">connect</span>(<span class="type">Sender</span> *<i>sender</i>, <span class="type">Signal</span> <i>signal</i>)</h3>
<p>Creates and returns a <a href="qfuture.html">QFuture</a> which will become available when the <i>sender</i> emits the <i>signal</i>. If the <i>signal</i> takes no arguments, a <a href="qfuture.html">QFuture</a>&lt;void&gt; is returned. If the <i>signal</i> takes a single argument, the resulted <a href="qfuture.html">QFuture</a> will be filled with the signal's argument value. If the <i>signal</i> takes multiple arguments, the resulted <a href="qfuture.html">QFuture</a> is filled with std::tuple storing the values of signal's arguments. If the <i>sender</i> is destroyed before the <i>signal</i> is emitted, the resulted <a href="qfuture.html">QFuture</a> will be canceled.</p>
<p>For example, let's say we have the following object:</p>
<pre class="cpp">
 <span class="keyword">class</span> Object : <span class="keyword">public</span> <span class="type"><a href="qobject.html">QObject</a></span>
 {
     Q_OBJECT
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">signals</span>:
     <span class="type">void</span> noArgSignal();
     <span class="type">void</span> singleArgSignal(<span class="type">int</span> value);
     <span class="type">void</span> multipleArgs(<span class="type">int</span> value1<span class="operator">,</span> <span class="type">double</span> value2<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qstring.html">QString</a></span> <span class="operator">&amp;</span>value3);
 };
</pre>
<p>We can connect its signals to <a href="qfuture.html">QFuture</a> objects in the following way:</p>
<pre class="cpp">
 Object object;
 <span class="type"><a href="qfuture.html">QFuture</a></span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> voidFuture <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>noArgSignal);
 <span class="type"><a href="qfuture.html">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> intFuture <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal);

 <span class="keyword">using</span> Args <span class="operator">=</span> std<span class="operator">::</span>tuple<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type">double</span><span class="operator">,</span> <span class="type"><a href="qstring.html">QString</a></span><span class="operator">&gt;</span>;
 <span class="type"><a href="qfuture.html">QFuture</a></span><span class="operator">&lt;</span>Args<span class="operator">&gt;</span> tupleFuture <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>multipleArgs)
</pre>
<p>We can also chain continuations to be run when a signal is emitted:</p>
<pre class="cpp">
 <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal)<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> value) {
     <span class="comment">// do something with the value</span>
 });
</pre>
<p>You can also start the continuation in a new thread or a custom thread pool using <a href="qtfuture.html#Launch-enum">QtFuture::Launch</a> policies. For example:</p>
<pre class="cpp">
 <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal)<span class="operator">.</span>then(<span class="type">QtFuture</span><span class="operator">::</span>Launch<span class="operator">::</span>Async<span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> value) {
     <span class="comment">// this will run in a new thread</span>
 });
</pre>
<p>Throwing an exception from a slot invoked by Qt's signal-slot connection is considered to be an undefined behavior, if it is not handled within the slot. But with QFuture::connect(), you can throw and handle exceptions from the continuations:</p>
<pre class="cpp">
 <span class="type">QtFuture</span><span class="operator">::</span>connect(<span class="operator">&amp;</span>object<span class="operator">,</span> <span class="operator">&amp;</span>Object<span class="operator">::</span>singleArgSignal)<span class="operator">.</span>then(<span class="operator">[</span><span class="operator">]</span>(<span class="type">int</span> value) {
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="keyword">throw</span> std<span class="operator">::</span>exception();
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span>(<span class="keyword">const</span> std<span class="operator">::</span>exception <span class="operator">&amp;</span>e) {
     <span class="comment">// handle the exception</span>
 })<span class="operator">.</span>onFailed(<span class="operator">[</span><span class="operator">]</span> {
     <span class="comment">// handle other exceptions</span>
 });
</pre>
<div class="admonition note">
<p><b>Note: </b>The connected future will be fulfilled only once, when the signal is emitted for the first time.</p>
</div>
<p><b>See also </b><a href="qfuture.html">QFuture</a> and <a href="qfuture.html#then">QFuture::then</a>().</p>
<!-- @@@connect -->
<!-- $$$makeExceptionalFuture[overload1]$$$makeExceptionalFutureconstQException& -->
<h3 class="fn" id="makeExceptionalFuture"><code>[since 6.1] </code>template &lt;typename T&gt; <span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtFuture::<span class="name">makeExceptionalFuture</span>(const <span class="type"><a href="qexception.html">QException</a></span> &amp;<i>exception</i>)</h3>
<p>Creates and returns a <a href="qfuture.html">QFuture</a> which already has an exception <i>exception</i>.</p>
<pre class="cpp">
 <span class="type"><a href="qexception.html">QException</a></span> e;
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeExceptionalFuture<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(e);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">try</span> {
     f<span class="operator">.</span>result(); <span class="comment">// throws QException</span>
 } <span class="keyword">catch</span> (<span class="type"><a href="qexception.html">QException</a></span> <span class="operator">&amp;</span>) {
     <span class="comment">// handle exception here</span>
 }
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html">QFuture</a>, <a href="qexception.html">QException</a>, and <a href="qtfuture.html#makeReadyFuture-1">QtFuture::makeReadyFuture</a>().</p>
<!-- @@@makeExceptionalFuture -->
<!-- $$$makeExceptionalFuture$$$makeExceptionalFuturestd::exception_ptr -->
<h3 class="fn" id="makeExceptionalFuture-1"><code>[since 6.1] </code>template &lt;typename T&gt; <span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtFuture::<span class="name">makeExceptionalFuture</span>(<span class="type">std::exception_ptr</span> <i>exception</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates and returns a <a href="qfuture.html">QFuture</a> which already has an exception <i>exception</i>.</p>
<pre class="cpp">
 <span class="keyword">struct</span> TestException
 {
 };
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">auto</span> exception <span class="operator">=</span> std<span class="operator">::</span>make_exception_ptr(TestException());
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeExceptionalFuture<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(exception);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">try</span> {
     f<span class="operator">.</span>result(); <span class="comment">// throws TestException</span>
 } <span class="keyword">catch</span> (TestException <span class="operator">&amp;</span>) {
     <span class="comment">// handle exception here</span>
 }
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html">QFuture</a>, <a href="qexception.html">QException</a>, and <a href="qtfuture.html#makeReadyFuture-1">QtFuture::makeReadyFuture</a>().</p>
<!-- @@@makeExceptionalFuture -->
<!-- $$$makeReadyFuture[overload1]$$$makeReadyFutureT&& -->
<h3 class="fn" id="makeReadyFuture"><code>[since 6.1] </code>template &lt;typename T, typename&gt; <span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">std::decay_t</span>&lt;<span class="type">T</span>&gt;&gt; QtFuture::<span class="name">makeReadyFuture</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates and returns a <a href="qfuture.html">QFuture</a> which already has a result <i>value</i>. The returned <a href="qfuture.html">QFuture</a> has a type of std::decay_t&lt;T&gt;, where T is not void.</p>
<pre class="cpp">
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyFuture(std<span class="operator">::</span>make_unique<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span>(<span class="number">42</span>));
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">const</span> <span class="type">int</span> result <span class="operator">=</span> <span class="operator">*</span>f<span class="operator">.</span>takeResult(); <span class="comment">// result == 42</span>
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html">QFuture</a> and <a href="qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyFuture -->
<!-- $$$makeReadyFuture$$$makeReadyFuture -->
<h3 class="fn" id="makeReadyFuture-1"><code>[since 6.1] </code><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">void</span>&gt; QtFuture::<span class="name">makeReadyFuture</span>()</h3>
<p>This is an overloaded function.</p>
<p>Creates and returns a void <a href="qfuture.html">QFuture</a>. Such <a href="qfuture.html">QFuture</a> can't store any result. One can use it to query the state of the computation. The returned <a href="qfuture.html">QFuture</a> will always be in the finished state.</p>
<pre class="cpp">
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyFuture();
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">const</span> bool started <span class="operator">=</span> f<span class="operator">.</span>isStarted(); <span class="comment">// started == true</span>
 <span class="keyword">const</span> bool running <span class="operator">=</span> f<span class="operator">.</span>isRunning(); <span class="comment">// running == false</span>
 <span class="keyword">const</span> bool finished <span class="operator">=</span> f<span class="operator">.</span>isFinished(); <span class="comment">// finished == true</span>
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html">QFuture</a>, <a href="qfuture.html#isStarted">QFuture::isStarted</a>(), <a href="qfuture.html#isRunning">QFuture::isRunning</a>(), <a href="qfuture.html#isFinished">QFuture::isFinished</a>(), and <a href="qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyFuture -->
<!-- $$$makeReadyFuture$$$makeReadyFutureconstQList<T>& -->
<h3 class="fn" id="makeReadyFuture-2"><code>[since 6.1] </code>template &lt;typename T&gt; <span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtFuture::<span class="name">makeReadyFuture</span>(const <span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>values</i>)</h3>
<p>This is an overloaded function.</p>
<p>Creates and returns a <a href="qfuture.html">QFuture</a> which already has multiple results set from <i>values</i>.</p>
<pre class="cpp">
 <span class="keyword">const</span> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> values { <span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span> };
 <span class="keyword">auto</span> f <span class="operator">=</span> <span class="type">QtFuture</span><span class="operator">::</span>makeReadyFuture(values);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="keyword">const</span> <span class="type">int</span> count <span class="operator">=</span> f<span class="operator">.</span>resultCount(); <span class="comment">// count == 3</span>
 <span class="keyword">const</span> <span class="keyword">auto</span> results <span class="operator">=</span> f<span class="operator">.</span>results(); <span class="comment">// results == { 1, 2, 3 }</span>
</pre>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qfuture.html">QFuture</a> and <a href="qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>().</p>
<!-- @@@makeReadyFuture -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
