<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qbytearray.cpp -->
  <title>QByteArray Class | Qt Core 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtcore-index.html">Qt Core</a></li>
<li><a href="qtcore-module.html">C++ Classes</a></li>
<li>QByteArray</li>
<li id="buildversion"><a href="qtcore-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions</a></li>
<li class="level2"><a href="#c-locale-and-ascii-functions">C locale and ASCII functions</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QByteArray Class</h1>
<!-- $$$QByteArray-brief -->
<p>The QByteArray class provides an array of bytes. <a href="#details">More...</a></p>
<!-- @@@QByteArray -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QByteArray&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></table></div>
<ul>
<li><a href="qbytearray-members.html">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qdoc/17-qdoc-commands-thread.html#reentrant">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qbytearray-frombase64result.html">FromBase64Result</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#Base64Option-enum">Base64Option</a></b> { Base64Encoding, Base64UrlEncoding, KeepTrailingEquals, OmitTrailingEquals, IgnoreBase64DecodingErrors, AbortOnBase64DecodingErrors }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#Base64Option-enum">Base64Options</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#const_iterator-typedef">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#const_reverse_iterator-typedef">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#iterator-typedef">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#reverse_iterator-typedef">reverse_iterator</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-3">QByteArray</a></b>(QByteArray &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray">QByteArray</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-2">QByteArray</a></b>(qsizetype <i>size</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray-1">QByteArray</a></b>(const char *<i>data</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArray">QByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-2">operator=</a></b>(QByteArray &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq">operator=</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#dtor.QByteArray">~QByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append">append</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-1">append</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-2">append</a></b>(qsizetype <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-3">append</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-4">append</a></b>(const char *<i>str</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#append-5">append</a></b>(QByteArrayView <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#at">at</a></b>(qsizetype <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#back">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#back-1">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#begin">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#begin-1">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#capacity">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#cbegin">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#cend">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#chop">chop</a></b>(qsizetype <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#chopped">chopped</a></b>(qsizetype <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#clear">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#compare">compare</a></b>(QByteArrayView <i>bv</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#constBegin">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#constData">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#constEnd">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#contains">contains</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#contains-1">contains</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count">count</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count-1">count</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#count-2">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#crbegin">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#crend">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#data">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#data-1">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#end">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#end-1">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#endsWith">endsWith</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#endsWith-1">endsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#erase">erase</a></b>(QByteArray::const_iterator <i>first</i>, QByteArray::const_iterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fill">fill</a></b>(char <i>ch</i>, qsizetype <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#first">first</a></b>(qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#front">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#front-1">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#indexOf">indexOf</a></b>(QByteArrayView <i>bv</i>, qsizetype <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#indexOf-1">indexOf</a></b>(char <i>ch</i>, qsizetype <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert">insert</a></b>(qsizetype <i>i</i>, QByteArrayView <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-1">insert</a></b>(qsizetype <i>i</i>, const char *<i>s</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-2">insert</a></b>(qsizetype <i>i</i>, const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-3">insert</a></b>(qsizetype <i>i</i>, qsizetype <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-4">insert</a></b>(qsizetype <i>i</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#insert-5">insert</a></b>(qsizetype <i>i</i>, const char *<i>data</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isEmpty">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isLower">isLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isNull">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#isUpper">isUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#last">last</a></b>(qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a></b>(QByteArrayView <i>bv</i>, qsizetype <i>from</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf-1">lastIndexOf</a></b>(char <i>ch</i>, qsizetype <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#lastIndexOf-2">lastIndexOf</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#left">left</a></b>(qsizetype <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#leftJustified">leftJustified</a></b>(qsizetype <i>width</i>, char <i>fill</i> = ' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#length">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#mid">mid</a></b>(qsizetype <i>pos</i>, qsizetype <i>len</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend">prepend</a></b>(QByteArrayView <i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-1">prepend</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-2">prepend</a></b>(qsizetype <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-3">prepend</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-4">prepend</a></b>(const char *<i>str</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#prepend-5">prepend</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back">push_back</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back-1">push_back</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back-2">push_back</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_back-3">push_back</a></b>(QByteArrayView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front">push_front</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front-1">push_front</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front-2">push_front</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#push_front-3">push_front</a></b>(QByteArrayView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rbegin">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rbegin-1">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#remove">remove</a></b>(qsizetype <i>pos</i>, qsizetype <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#removeIf">removeIf</a></b>(Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rend">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rend-1">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#repeated">repeated</a></b>(qsizetype <i>times</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace">replace</a></b>(qsizetype <i>pos</i>, qsizetype <i>len</i>, QByteArrayView <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-1">replace</a></b>(qsizetype <i>pos</i>, qsizetype <i>len</i>, const char *<i>after</i>, qsizetype <i>alen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-2">replace</a></b>(char <i>before</i>, QByteArrayView <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-3">replace</a></b>(const char *<i>before</i>, qsizetype <i>bsize</i>, const char *<i>after</i>, qsizetype <i>asize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-4">replace</a></b>(QByteArrayView <i>before</i>, QByteArrayView <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#replace-5">replace</a></b>(char <i>before</i>, char <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#reserve">reserve</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#resize">resize</a></b>(qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#right">right</a></b>(qsizetype <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#rightJustified">rightJustified</a></b>(qsizetype <i>width</i>, char <i>fill</i> = ' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum">setNum</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-1">setNum</a></b>(short <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-2">setNum</a></b>(ushort <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-3">setNum</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-4">setNum</a></b>(long <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-5">setNum</a></b>(ulong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-6">setNum</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-7">setNum</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-8">setNum</a></b>(float <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setNum-9">setNum</a></b>(double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#setRawData">setRawData</a></b>(const char *<i>data</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#shrink_to_fit">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#simplified">simplified</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#sliced">sliced</a></b>(qsizetype <i>pos</i>, qsizetype <i>n</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#sliced-1">sliced</a></b>(qsizetype <i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#split">split</a></b>(char <i>sep</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#squeeze">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#startsWith">startsWith</a></b>(QByteArrayView <i>bv</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#startsWith-1">startsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#swap">swap</a></b>(QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toBase64">toBase64</a></b>(QByteArray::Base64Options <i>options</i> = Base64Encoding) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFDataRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toCFData">toCFData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toDouble">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toFloat">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toHex">toHex</a></b>(char <i>separator</i> = '\0') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toInt">toInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toLong">toLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toLongLong">toLongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toLower">toLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSData *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toNSData">toNSData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toPercentEncoding">toPercentEncoding</a></b>(const QByteArray &amp;<i>exclude</i> = QByteArray(), const QByteArray &amp;<i>include</i> = QByteArray(), char <i>percent</i> = '%') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFDataRef </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toRawCFData">toRawCFData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSData *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toRawNSData">toRawNSData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> short </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toShort">toShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::string </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toStdString">toStdString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toUInt">toUInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ulong </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toULong">toULong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toULongLong">toULongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ushort </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toUShort">toUShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#toUpper">toUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#trimmed">trimmed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#truncate">truncate</a></b>(qsizetype <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-const-char--2a">operator const char *</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const void *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-const-void--2a">operator const void *</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq">operator!=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq">operator+=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq-1">operator+=</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-eq-2">operator+=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt">operator&lt;</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq">operator&lt;=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-1">operator=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq">operator==</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt">operator&gt;</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq">operator&gt;=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-5b-5d">operator[]</a></b>(qsizetype <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-5b-5d-1">operator[]</a></b>(qsizetype <i>i</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromBase64">fromBase64</a></b>(const QByteArray &amp;<i>base64</i>, QByteArray::Base64Options <i>options</i> = Base64Encoding)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::FromBase64Result </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromBase64Encoding">fromBase64Encoding</a></b>(QByteArray &amp;&amp;<i>base64</i>, QByteArray::Base64Options <i>options</i> = Base64Encoding)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::FromBase64Result </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromBase64Encoding-1">fromBase64Encoding</a></b>(const QByteArray &amp;<i>base64</i>, QByteArray::Base64Options <i>options</i> = Base64Encoding)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromCFData">fromCFData</a></b>(CFDataRef <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromHex">fromHex</a></b>(const QByteArray &amp;<i>hexEncoded</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromNSData">fromNSData</a></b>(const NSData *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</a></b>(const QByteArray &amp;<i>input</i>, char <i>percent</i> = '%')</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromRawCFData">fromRawCFData</a></b>(CFDataRef <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromRawData">fromRawData</a></b>(const char *<i>data</i>, qsizetype <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromRawNSData">fromRawNSData</a></b>(const NSData *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#fromStdString">fromStdString</a></b>(const std::string &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number">number</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-1">number</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-2">number</a></b>(long <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-3">number</a></b>(ulong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-4">number</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-5">number</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#number-6">number</a></b>(double <i>n</i>, char <i>format</i> = 'g', int <i>precision</i> = 6)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#erase-1">erase</a></b>(QByteArray &amp;<i>ba</i>, const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qsizetype </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#erase_if">erase_if</a></b>(QByteArray &amp;<i>ba</i>, Predicate <i>pred</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qChecksum">qChecksum</a></b>(QByteArrayView <i>data</i>, Qt::ChecksumType <i>standard</i> = Qt::ChecksumIso3309)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qCompress">qCompress</a></b>(const QByteArray &amp;<i>data</i>, int <i>compressionLevel</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qCompress-1">qCompress</a></b>(const uchar *<i>data</i>, qsizetype <i>nbytes</i>, int <i>compressionLevel</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qUncompress-1">qUncompress</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qUncompress-2">qUncompress</a></b>(const uchar *<i>data</i>, qsizetype <i>nbytes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qsnprintf">qsnprintf</a></b>(char *<i>str</i>, size_t <i>n</i>, const char *<i>fmt</i>, ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrcmp">qstrcmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrcpy">qstrcpy</a></b>(char *<i>dst</i>, const char *<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrdup">qstrdup</a></b>(const char *<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstricmp">qstricmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrlen">qstrlen</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrncmp">qstrncmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>, size_t <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrncpy">qstrncpy</a></b>(char *<i>dst</i>, const char *<i>src</i>, size_t <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrnicmp">qstrnicmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>, size_t <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qstrnlen">qstrnlen</a></b>(const char *<i>str</i>, size_t <i>maxlen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#qvsnprintf">qvsnprintf</a></b>(char *<i>str</i>, size_t <i>n</i>, const char *<i>fmt</i>, va_list <i>ap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq-1">operator!=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq-2">operator!=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-not-eq-3">operator!=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-22-22_qba">operator&quot;&quot;_qba</a></b>(const char *<i>str</i>, size_t <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b">operator+</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-1">operator+</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-2">operator+</a></b>(const QByteArray &amp;<i>a1</i>, char <i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-3">operator+</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-2b-4">operator+</a></b>(char <i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-1">operator&lt;</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-2">operator&lt;</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-3">operator&lt;</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-lt">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq-1">operator&lt;=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq-2">operator&lt;=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-lt-eq-3">operator&lt;=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq-1">operator==</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq-2">operator==</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-eq-eq-3">operator==</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-1">operator&gt;</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-2">operator&gt;</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-3">operator&gt;</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq-1">operator&gt;=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq-2">operator&gt;=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-eq-3">operator&gt;=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QByteArray &amp;<i>ba</i>)</td></tr>
</table></div>
<h2 id="macros">Macros</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a></b>(<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a></b></td></tr>
</table></div>
<!-- $$$QByteArray-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QByteArray can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using QByteArray is much more convenient than using <code>const char *</code>. Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses <a href="implicit-sharing.html">implicit sharing</a> (copy-on-write) to reduce memory usage and avoid needless copying of data.</p>
<p>In addition to QByteArray, Qt also provides the <a href="qstring.html">QString</a> class to store string data. For most purposes, <a href="qstring.html">QString</a> is the class you want to use. It understands its content as Unicode text (encoded using UTF-16) where QByteArray aims to avoid assumptions about the encoding or semantics of the bytes it stores (aside from a few legacy cases where it uses ASCII). Furthermore, <a href="qstring.html">QString</a> is used throughout in the Qt API. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g&#x2e;, with Qt for Embedded Linux).</p>
<p>One way to initialize a QByteArray is simply to pass a <code>const char *</code> to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello&quot;</span>);
</pre>
<p>Although the <a href="qbytearray.html#size">size</a>() is 5, the byte array also maintains an extra '\0' byte at the end so that if a function is used that asks for a pointer to the underlying data (e.g&#x2e; a call to <a href="qbytearray.html#data">data</a>()), the data pointed to is guaranteed to be '\0'-terminated.</p>
<p>QByteArray makes a deep copy of the <code>const char *</code> data, so you can modify it later without experiencing side effects. (If, for example for performance reasons, you don't want to take a deep copy of the data, use <a href="qbytearray.html#fromRawData">QByteArray::fromRawData</a>() instead.)</p>
<p>Another approach is to set the size of the array using <a href="qbytearray.html#resize">resize</a>() and to initialize the data byte by byte. QByteArray uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba;
 ba<span class="operator">.</span>resize(<span class="number">5</span>);
 ba<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x3c</span>;
 ba<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xb8</span>;
 ba<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x64</span>;
 ba<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x18</span>;
 ba<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xca</span>;
</pre>
<p>For read-only access, an alternative syntax is to use <a href="qbytearray.html#at">at</a>():</p>
<pre class="cpp">
 <span class="keyword">for</span> (qsizetype i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> ba<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
     <span class="keyword">if</span> (ba<span class="operator">.</span>at(i) <span class="operator">&gt;</span><span class="operator">=</span> <span class="char">'a'</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> ba<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">=</span> <span class="char">'f'</span>)
         cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found character in range [a-f]&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
 }
</pre>
<p><a href="qbytearray.html#at">at</a>() can be faster than operator[](), because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>To extract many bytes at a time, use <a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#last">last</a>(), or <a href="qbytearray.html#sliced">sliced</a>().</p>
<p>A QByteArray can embed '\0' bytes. The <a href="qbytearray.html#size">size</a>() function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by QByteArray. For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba1(<span class="string">&quot;ca\0r\0t&quot;</span>);
 ba1<span class="operator">.</span>size();                     <span class="comment">// Returns 2.</span>
 ba1<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca&quot; with terminating \0.</span>

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba2(<span class="string">&quot;ca\0r\0t&quot;</span><span class="operator">,</span> <span class="number">3</span>);
 ba2<span class="operator">.</span>size();                     <span class="comment">// Returns 3.</span>
 ba2<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca\0&quot; with terminating \0.</span>

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba3(<span class="string">&quot;ca\0r\0t&quot;</span><span class="operator">,</span> <span class="number">4</span>);
 ba3<span class="operator">.</span>size();                     <span class="comment">// Returns 4.</span>
 ba3<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca\0r&quot; with terminating \0.</span>

 <span class="keyword">const</span> <span class="type">char</span> cart<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="char">'c'</span><span class="operator">,</span> <span class="char">'a'</span><span class="operator">,</span> <span class="char">'\0'</span><span class="operator">,</span> <span class="char">'r'</span><span class="operator">,</span> <span class="char">'\0'</span><span class="operator">,</span> <span class="char">'t'</span>};
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba4(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromRawData(cart<span class="operator">,</span> <span class="number">6</span>));
 ba4<span class="operator">.</span>size();                     <span class="comment">// Returns 6.</span>
 ba4<span class="operator">.</span>constData();                <span class="comment">// Returns &quot;ca\0r\0t&quot; without terminating \0.</span>
</pre>
<p>If you want to obtain the length of the data up to and excluding the first '\0' byte, call <a href="qbytearray.html#qstrlen">qstrlen</a>() on the byte array.</p>
<p>After a call to <a href="qbytearray.html#resize">resize</a>(), newly allocated bytes have undefined values. To set all the bytes to a particular value, call <a href="qbytearray.html#fill">fill</a>().</p>
<p>To obtain a pointer to the actual bytes, call <a href="qbytearray.html#data">data</a>() or <a href="qbytearray.html#constData">constData</a>(). These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the QByteArray. It is also guaranteed that the data ends with a '\0' byte unless the QByteArray was created from <a href="qbytearray.html#fromRawData">raw data</a>. This '\0' byte is automatically provided by QByteArray and is not counted in <a href="qbytearray.html#size">size</a>().</p>
<p>QByteArray provides the following basic functions for modifying the byte data: <a href="qbytearray.html#append">append</a>(), <a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#insert">insert</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>(). For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;and&quot;</span>);
 x<span class="operator">.</span>prepend(<span class="string">&quot;rock &quot;</span>);         <span class="comment">// x == &quot;rock and&quot;</span>
 x<span class="operator">.</span>append(<span class="string">&quot; roll&quot;</span>);          <span class="comment">// x == &quot;rock and roll&quot;</span>
 x<span class="operator">.</span>replace(<span class="number">5</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="string">&quot;&amp;&quot;</span>);       <span class="comment">// x == &quot;rock &amp; roll&quot;</span>
</pre>
<p>In the above example the <a href="qbytearray.html#replace">replace</a>() function's first two arguments are the position from which to start replacing and the number of bytes that should be replaced.</p>
<p>When data-modifying functions increase the size of the array, they may lead to reallocation of memory for the QByteArray object. When this happens, QByteArray expands by more than it immediately needs so as to have space for further expansion without reallocation until the size of the array has greatly increased.</p>
<p>The <a href="qbytearray.html#insert">insert</a>(), <a href="qbytearray.html#remove">remove</a>() and, when replacing a sub-array with one of different size, <a href="qbytearray.html#replace">replace</a>() functions can be slow (<a href="containers.html#linear-time">linear time</a>) for large arrays, because they require moving many bytes in the array by at least one position in memory.</p>
<p>If you are building a QByteArray gradually and know in advance approximately how many bytes the QByteArray will contain, you can call <a href="qbytearray.html#reserve">reserve</a>(), asking QByteArray to preallocate a certain amount of memory. You can also call <a href="qbytearray.html#capacity">capacity</a>() to find out how much memory the QByteArray actually has allocated.</p>
<p>Note that using non-const operators and functions can cause QByteArray to do a deep copy of the data, due to <a href="implicit-sharing.html">implicit sharing</a>.</p>
<p>QByteArray provides <a href="containers.html#stl-style-iterators">STL-style iterators</a> (<a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a> and <a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a>). In practice, iterators are handy when working with generic algorithms provided by the C++ standard library.</p>
<div class="admonition note">
<p><b>Note: </b>Iterators and references to individual QByteArray elements are subject to stability issues. They are often invalidated when a QByteArray-modifying operation (e.g&#x2e; <a href="qbytearray.html#insert">insert</a>() or <a href="qbytearray.html#remove">remove</a>()) is called. When stability and iterator-like functionality is required, you should use indexes instead of iterators as they are not tied to QByteArray's internal state and thus do not get invalidated.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Iterators over a QByteArray, and references to individual bytes within one, cannot be relied on to remain valid when any non-const method of the QByteArray is called. Accessing such an iterator or reference after the call to a non-const method leads to undefined behavior. When stability for iterator-like functionality is required, you should use indexes instead of iterators as they are not tied to QByteArray's internal state and thus do not get invalidated.</p>
</div>
<p>If you want to find all occurrences of a particular byte or sequence of bytes in a QByteArray, use <a href="qbytearray.html#indexOf">indexOf</a>() or <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the byte sequence if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular string:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;&quot;</span>);
 qsizetype j <span class="operator">=</span> <span class="number">0</span>;
 <span class="keyword">while</span> ((j <span class="operator">=</span> ba<span class="operator">.</span>indexOf(<span class="string">&quot;&lt;b&gt;&quot;</span><span class="operator">,</span> j)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Found &lt;b&gt; tag at index position &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> j <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
     <span class="operator">+</span><span class="operator">+</span>j;
 }
</pre>
<p>If you simply want to check whether a QByteArray contains a particular byte sequence, use <a href="qbytearray.html#contains">contains</a>(). If you want to find out how many times a particular byte sequence occurs in the byte array, use <a href="qbytearray.html#count-2">count</a>(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter <a href="qbytearray.html#replace">replace</a>() overloads.</p>
<p><a href="qbytearray.html">QByteArray</a>s can be compared using overloaded operators such as operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and so on. The comparison is based exclusively on the numeric values of the bytes and is very fast, but is not what a human would expect. <a href="qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() is a better choice for sorting user-interface strings.</p>
<p>For historical reasons, QByteArray distinguishes between a null byte array and an empty byte array. A <i>null</i> byte array is a byte array that is initialized using QByteArray's default constructor or by passing (const char *)0 to the constructor. An <i>empty</i> byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span>
</pre>
<p>All functions except <a href="qbytearray.html#isNull">isNull</a>() treat null byte arrays the same as empty byte arrays. For example, <a href="qbytearray.html#data">data</a>() returns a valid pointer (<i>not</i> nullptr) to a '\0' byte for a null byte array and QByteArray() compares equal to QByteArray(&quot;&quot;). We recommend that you always use <a href="qbytearray.html#isEmpty">isEmpty</a>() and avoid <a href="qbytearray.html#isNull">isNull</a>().</p>
<h3 id="maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions</h3>
<p>The maximum size of QByteArray depends on the architecture. Most 64-bit systems can allocate more than 2 GB of memory, with a typical limit of 2^63 bytes. The actual value also depends on the overhead required for managing the data block. As a result, you can expect the maximum size of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead on 64-bit platforms. The number of elements that can be stored in a QByteArray is this maximum size.</p>
<p>When memory allocation fails, QByteArray throws a <code>std::bad_alloc</code> exception if the application is being compiled with exception support. Out of memory conditions in Qt containers are the only case where Qt will throw exceptions. If exceptions are disabled, then running out of memory is undefined behavior.</p>
<p>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the QByteArray API.</p>
<h3 id="c-locale-and-ascii-functions">C locale and ASCII functions</h3>
<p>QByteArray generally handles data as bytes, without presuming any semantics; where it does presume semantics, it uses the C locale and ASCII encoding. Standard Unicode encodings are supported by <a href="qstring.html">QString</a>, other encodings may be supported using <a href="qstringencoder.html">QStringEncoder</a> and <a href="qstringdecoder.html">QStringDecoder</a> to convert to Unicode. For locale-specific interpretation of text, use <a href="qlocale.html">QLocale</a> or <a href="qstring.html">QString</a>.</p>
<h4 id="c-strings">C Strings</h4>
<p>Traditional C strings, also known as '\0'-terminated strings, are sequences of bytes, specified by a start-point and implicitly including each byte up to, but not including, the first '\0' byte thereafter. Methods that accept such a pointer, without a length, will interpret it as this sequence of bytes. Such a sequence, by construction, cannot contain a '\0' byte.</p>
<p>Other overloads accept a start-pointer and a byte-count; these use the given number of bytes, following the start address, regardless of whether any of them happen to be '\0' bytes. In some cases, where there is no overload taking only a pointer, passing a length of -1 will cause the method to use the offset of the first '\0' byte after the pointer as the length; a length of -1 should only be passed if the method explicitly says it does this (in which case it is typically a default argument).</p>
<h4 id="spacing-characters">Spacing Characters</h4>
<p>A frequent requirement is to remove spacing characters from a byte array (<code>'\n'</code>, <code>'\t'</code>, <code>' '</code>, etc.)&#x2e; If you want to remove spacing from both ends of a QByteArray, use <a href="qbytearray.html#trimmed">trimmed</a>(). If you want to also replace each run of spacing characters with a single space character within the byte array, use <a href="qbytearray.html#simplified">simplified</a>(). Only ASCII spacing characters are recognized for these purposes.</p>
<h4 id="number-string-conversions">Number-String Conversions</h4>
<p>Functions that perform conversions between numeric data types and string representations are performed in the C locale, regardless of the user's locale settings. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
<h4 id="character-case">Character Case</h4>
<p>In QByteArray, the notion of uppercase and lowercase and of case-independent comparison is limited to ASCII. Non-ASCII characters are treated as caseless, since their case depends on encoding. This affects functions that support a case insensitive option or that change the case of their arguments. Functions that this affects include <a href="qbytearray.html#contains">contains</a>(), <a href="qbytearray.html#indexOf">indexOf</a>(), <a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(), <a href="qbytearray.html#isLower">isLower</a>(), <a href="qbytearray.html#isUpper">isUpper</a>(), <a href="qbytearray.html#toLower">toLower</a>() and <a href="qbytearray.html#toUpper">toUpper</a>().</p>
<p>This issue does not apply to <a href="qstring.html">QString</a>s since they represent characters using Unicode.</p>
</div>
<p><b>See also </b><a href="qbytearrayview.html">QByteArrayView</a>, <a href="qstring.html">QString</a>, and <a href="qbitarray.html">QBitArray</a>.</p>
<!-- @@@QByteArray -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Base64Option$$$Base64Encoding$$$Base64UrlEncoding$$$KeepTrailingEquals$$$OmitTrailingEquals$$$IgnoreBase64DecodingErrors$$$AbortOnBase64DecodingErrors -->
<h3 class="flags" id="Base64Option-enum"><code>[since 5.2] </code>enum QByteArray::<span class="name">Base64Option</span><br/>flags QByteArray::<span class="name">Base64Options</span></h3>
<p>This enum contains the options available for encoding and decoding Base64. Base64 is defined by <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a>, with the following options:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QByteArray::Base64Encoding</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">(default) The regular Base64 alphabet, called simply &quot;base64&quot;</td></tr>
<tr><td class="topAlign"><code>QByteArray::Base64UrlEncoding</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">An alternate alphabet, called &quot;base64url&quot;, which replaces two characters in the alphabet to be more friendly to URLs.</td></tr>
<tr><td class="topAlign"><code>QByteArray::KeepTrailingEquals</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">(default) Keeps the trailing padding equal signs at the end of the encoded data, so the data is always a size multiple of four.</td></tr>
<tr><td class="topAlign"><code>QByteArray::OmitTrailingEquals</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Omits adding the padding equal signs at the end of the encoded data.</td></tr>
<tr><td class="topAlign"><code>QByteArray::IgnoreBase64DecodingErrors</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</td></tr>
<tr><td class="topAlign"><code>QByteArray::AbortOnBase64DecodingErrors</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</td></tr>
</table></div>
<p><a href="qbytearray.html#fromBase64Encoding">QByteArray::fromBase64Encoding</a>() and <a href="qbytearray.html#fromBase64">QByteArray::fromBase64</a>() ignore the KeepTrailingEquals and OmitTrailingEquals options. If the IgnoreBase64DecodingErrors option is specified, they will not flag errors in case trailing equal signs are missing or if there are too many of them. If instead the AbortOnBase64DecodingErrors is specified, then the input must either have no padding or have the correct amount of equal signs.</p>
<p>This enum was introduced or modified in Qt 5.2.</p>
<p>The Base64Options type is a typedef for <a href="qflags.html">QFlags</a>&lt;Base64Option&gt;. It stores an OR combination of Base64Option values.</p>
<!-- @@@Base64Option -->
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef">QByteArray::<span class="name">const_iterator</span></h3>
<p>This typedef provides an STL-style const iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p><b>See also </b><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> and <a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef"><code>[since 5.6] </code>QByteArray::<span class="name">const_reverse_iterator</span></h3>
<p>This typedef provides an STL-style const reverse iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a> and <a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedef">QByteArray::<span class="name">iterator</span></h3>
<p>This typedef provides an STL-style non-const iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p><b>See also </b><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a> and <a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef"><code>[since 5.6] </code>QByteArray::<span class="name">reverse_iterator</span></h3>
<p>This typedef provides an STL-style non-const reverse iterator for <a href="qbytearray.html">QByteArray</a>.</p>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> and <a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a>.</p>
<!-- @@@reverse_iterator -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="fromBase64Encoding"><code>[static, since 5.15] </code><span class="type"><a href="qbytearray-frombase64result.html">QByteArray::FromBase64Result</a></span> QByteArray::<span class="name">fromBase64Encoding</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;&amp;<i>base64</i>, <span class="type"><a href="qbytearray.html#Base64Option-enum">QByteArray::Base64Options</a></span> <i>options</i> = Base64Encoding)</h3><h3 class="fn fngroupitem" id="fromBase64Encoding-1"><code>[static, since 5.15] </code><span class="type"><a href="qbytearray-frombase64result.html">QByteArray::FromBase64Result</a></span> QByteArray::<span class="name">fromBase64Encoding</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>base64</i>, <span class="type"><a href="qbytearray.html#Base64Option-enum">QByteArray::Base64Options</a></span> <i>options</i> = Base64Encoding)</h3></div>
<p>This is an overloaded function.</p>
<p>Decodes the Base64 array <i>base64</i>, using the options defined by <i>options</i>. If <i>options</i> contains <code>IgnoreBase64DecodingErrors</code> (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If <i>options</i> contains <code>AbortOnBase64DecodingErrors</code>, then decoding will stop at the first invalid character.</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type">void</span> process(<span class="keyword">const</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="operator">&amp;</span>);

 <span class="keyword">if</span> (<span class="keyword">auto</span> result <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64Encoding(encodedData))
     process(<span class="operator">*</span>result);
</pre>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a>.</p>
<p>Returns a QByteArrayFromBase64Result object, containing the decoded data and a flag telling whether decoding was successful. If the <code>AbortOnBase64DecodingErrors</code> option was passed and the input data was invalid, it is unspecified what the decoded data contains.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="qbytearray.html#toBase64">toBase64</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="operator-const-char--2a">const <span class="type">char</span> *QByteArray::<span class="name">operator const char *</span>() const</h3><h3 class="fn fngroupitem" id="operator-const-void--2a">const <span class="type">void</span> *QByteArray::<span class="name">operator const void *</span>() const</h3></div>
<div class="admonition note">
<p><b>Note: </b>Use <a href="qbytearray.html#constData">constData</a>() instead in new code.</p>
</div>
<p>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated.</p>
<p>The pointer remains valid as long as no detach happens and the <a href="qbytearray.html">QByteArray</a> is not modified. This operator is mostly useful to pass a byte array to a function that accepts a <code>const char *</code>.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_BYTEARRAY</code> when you compile your applications.</p>
<p>Note: A <a href="qbytearray.html">QByteArray</a> can store any byte values including '\0's, but most functions that take <code>char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>See also </b><a href="qbytearray.html#constData">constData</a>().</p>
<!-- @@@ -->
<!-- $$$QByteArray$$$QByteArrayQByteArray&& -->
<h3 class="fn" id="QByteArray-3"><code>[since 5.2] </code>QByteArray::<span class="name">QByteArray</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-constructs a QByteArray instance, making it point at the same object that <i>other</i> was pointing to.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray[overload1]$$$QByteArrayconstQByteArray& -->
<h3 class="fn" id="QByteArray">QByteArray::<span class="name">QByteArray</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation takes <a href="containers.html#constant-time">constant time</a>, because QByteArray is <a href="implicit-sharing.html">implicitly shared</a>. This makes returning a QByteArray from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p><b>See also </b><a href="qbytearray.html#operator-eq">operator=</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayqsizetypechar -->
<h3 class="fn" id="QByteArray-2">QByteArray::<span class="name">QByteArray</span>(<span class="type">qsizetype</span> <i>size</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>Constructs a byte array of size <i>size</i> with every byte set to <i>ch</i>.</p>
<p><b>See also </b><a href="qbytearray.html#fill">fill</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayconstchar*qsizetype -->
<h3 class="fn" id="QByteArray-1">QByteArray::<span class="name">QByteArray</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Constructs a byte array containing the first <i>size</i> bytes of array <i>data</i>.</p>
<p>If <i>data</i> is 0, a null byte array is constructed.</p>
<p>If <i>size</i> is negative, <i>data</i> is assumed to point to a '\0'-terminated string and its length is determined dynamically.</p>
<p>QByteArray makes a deep copy of the string data.</p>
<p><b>See also </b><a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray[overload1]$$$QByteArray -->
<h3 class="fn" id="QByteArray">QByteArray::<span class="name">QByteArray</span>()</h3>
<p>Constructs an empty byte array.</p>
<p><b>See also </b><a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$operator=$$$operator=QByteArray&& -->
<h3 class="fn" id="operator-eq-2"><code>[since 5.2] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i>other</i> to this <a href="qbytearray.html">QByteArray</a> instance.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@operator= -->
<!-- $$$operator=[overload1]$$$operator=constQByteArray& -->
<h3 class="fn" id="operator-eq"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>Assigns <i>other</i> to this byte array and returns a reference to this byte array.</p>
<!-- @@@operator= -->
<!-- $$$~QByteArray[overload1]$$$~QByteArray -->
<h3 class="fn" id="dtor.QByteArray">QByteArray::<span class="name">~QByteArray</span>()</h3>
<p>Destroys the byte array.</p>
<!-- @@@~QByteArray -->
<!-- $$$append[overload1]$$$appendconstQByteArray& -->
<h3 class="fn" id="append"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Appends the byte array <i>ba</i> onto the end of this byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;free&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;dom&quot;</span>);
 x<span class="operator">.</span>append(y);
 <span class="comment">// x == &quot;freedom&quot;</span>
</pre>
<p>This is the same as insert(<a href="qbytearray.html#size">size</a>(), <i>ba</i>).</p>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <i>ba</i>. In this case, no copying of data is done, taking <a href="containers.html#constant-time">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>The append() function is typically very fast (<a href="containers.html#constant-time">constant time</a>), because <a href="qbytearray.html">QByteArray</a> preallocates extra space at the end of the data, so it can grow without reallocating the entire array each time.</p>
<p><b>See also </b><a href="qbytearray.html#operator-2b-eq">operator+=</a>(), <a href="qbytearray.html#prepend">prepend</a>(), and <a href="qbytearray.html#insert">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendchar -->
<h3 class="fn" id="append-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the byte <i>ch</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$append$$$appendqsizetypechar -->
<h3 class="fn" id="append-2"><code>[since 5.7] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type">qsizetype</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends <i>count</i> copies of byte <i>ch</i> to this byte array and returns a reference to this byte array.</p>
<p>If <i>count</i> is negative or zero nothing is appended to the byte array.</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar* -->
<h3 class="fn" id="append-3"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the '\0'-terminated string <i>str</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar*qsizetype -->
<h3 class="fn" id="append-4"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the first <i>len</i> bytes starting at <i>str</i> to this byte array and returns a reference to this byte array. The bytes appended may include '\0' bytes.</p>
<p>If <i>len</i> is negative, <i>str</i> will be assumed to be a '\0'-terminated string and the length to be copied will be determined automatically using <a href="qbytearray.html#qstrlen">qstrlen</a>().</p>
<p>If <i>len</i> is zero or <i>str</i> is null, nothing is appended to the byte array. Ensure that <i>len</i> is <i>not</i> longer than <i>str</i>.</p>
<!-- @@@append -->
<!-- $$$append$$$appendQByteArrayView -->
<h3 class="fn" id="append-5"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>data</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends <i>data</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$at[overload1]$$$atqsizetype -->
<h3 class="fn" id="at"><span class="type">char</span> QByteArray::<span class="name">at</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>Returns the byte at index position <i>i</i> in the byte array.</p>
<p><i>i</i> must be a valid index position in the byte array (i.e&#x2e;, 0 &lt;= <i>i</i> &lt; <a href="qbytearray.html#size">size</a>()).</p>
<p><b>See also </b><a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back"><code>[since 5.10] </code><span class="type">char</span> QByteArray::<span class="name">back</span>() const</h3>
<p>Returns the last byte in the byte array. Same as <code>at(size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qbytearray.html#front">front</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1"><code>[since 5.10] </code><span class="type">char</span> &amp;QByteArray::<span class="name">back</span>()</h3>
<p>Returns a reference to the last byte in the byte array. Same as <code>operator[](size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qbytearray.html#front">front</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin"><span class="type"><a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a></span> QByteArray::<span class="name">begin</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first byte in the byte-array.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#constBegin">constBegin</a>() and <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1"><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">begin</span>() const</h3>
<p>This function overloads begin().</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity"><span class="type">qsizetype</span> QByteArray::<span class="name">capacity</span>() const</h3>
<p>Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call <a href="qbytearray.html#size">size</a>().</p>
<div class="admonition note">
<p><b>Note: </b>a statically allocated byte array will report a capacity of 0, even if it's not empty.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The free space position in the allocated memory block is undefined. In other words, one should not assume that the free memory is always located after the initialized elements.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#reserve">reserve</a>() and <a href="qbytearray.html#squeeze">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin"><code>[since 5.0] </code><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">cbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first byte in the byte-array.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="qbytearray.html#begin">begin</a>() and <a href="qbytearray.html#cend">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend"><code>[since 5.0] </code><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">cend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing just after the last byte in the byte-array.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="qbytearray.html#cbegin">cbegin</a>() and <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@cend -->
<!-- $$$chop[overload1]$$$chopqsizetype -->
<h3 class="fn" id="chop"><span class="type">void</span> QByteArray::<span class="name">chop</span>(<span class="type">qsizetype</span> <i>n</i>)</h3>
<p>Removes <i>n</i> bytes from the end of the byte array.</p>
<p>If <i>n</i> is greater than <a href="qbytearray.html#size">size</a>(), the result is an empty byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;STARTTLS\r\n&quot;</span>);
 ba<span class="operator">.</span>chop(<span class="number">2</span>);                 <span class="comment">// ba == &quot;STARTTLS&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#truncate">truncate</a>(), <a href="qbytearray.html#resize">resize</a>(), and <a href="qbytearray.html#first">first</a>().</p>
<!-- @@@chop -->
<!-- $$$chopped[overload1]$$$choppedqsizetype -->
<h3 class="fn" id="chopped"><code>[since 5.10] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">chopped</span>(<span class="type">qsizetype</span> <i>len</i>) const</h3>
<p>Returns a byte array that contains the leftmost <a href="qbytearray.html#size">size</a>() - <i>len</i> bytes of this byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined if <i>len</i> is negative or greater than <a href="qbytearray.html#size">size</a>().</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qbytearray.html#endsWith">endsWith</a>(), <a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#sliced">sliced</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@chopped -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear"><span class="type">void</span> QByteArray::<span class="name">clear</span>()</h3>
<p>Clears the contents of the byte array and makes it null.</p>
<p><b>See also </b><a href="qbytearray.html#resize">resize</a>() and <a href="qbytearray.html#isNull">isNull</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareQByteArrayViewQt::CaseSensitivity -->
<h3 class="fn" id="compare"><code>[since 6.0] </code><span class="type">int</span> QByteArray::<span class="name">compare</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>, <span class="type"><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const</h3>
<p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="qbytearray.html">QByteArray</a> sorts before, at the same position as, or after the <a href="qbytearrayview.html">QByteArrayView</a> <i>bv</i>. The comparison is performed according to case sensitivity <i>cs</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#operator-eq-eq">operator==</a> and <a href="qbytearray.html#character-case">Character Case</a>.</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin"><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">constBegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first byte in the byte-array.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#begin">begin</a>() and <a href="qbytearray.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" id="constData">const <span class="type">char</span> *QByteArray::<span class="name">constData</span>() const</h3>
<p>Returns a pointer to the const data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated unless the <a href="qbytearray.html">QByteArray</a> object was created from raw data.</p>
<p>The pointer remains valid as long as no detach happens and the <a href="qbytearray.html">QByteArray</a> is not modified.</p>
<p>This function is mostly useful to pass a byte array to a function that accepts a <code>const char *</code>.</p>
<p>Note: A <a href="qbytearray.html">QByteArray</a> can store any byte values including '\0's, but most functions that take <code>char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>See also </b><a href="qbytearray.html#data">data</a>(), <a href="qbytearray.html#operator-5b-5d">operator[]</a>(), and <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd"><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">constEnd</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing just after the last byte in the byte-array.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#constBegin">constBegin</a>() and <a href="qbytearray.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$contains[overload1]$$$containsQByteArrayView -->
<h3 class="fn" id="contains"><code>[since 6.0] </code><span class="type">bool</span> QByteArray::<span class="name">contains</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>Returns <code>true</code> if this byte array contains an occurrence of the sequence of bytes viewed by <i>bv</i>; otherwise returns <code>false</code>.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#indexOf">indexOf</a>() and <a href="qbytearray.html#count-2">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containschar -->
<h3 class="fn" id="contains-1"><span class="type">bool</span> QByteArray::<span class="name">contains</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if the byte array contains the byte <i>ch</i>; otherwise returns <code>false</code>.</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countQByteArrayView -->
<h3 class="fn" id="count"><code>[since 6.0] </code><span class="type">qsizetype</span> QByteArray::<span class="name">count</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>Returns the number of (potentially overlapping) occurrences of the sequence of bytes viewed by <i>bv</i> in this byte array.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#contains">contains</a>() and <a href="qbytearray.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countchar -->
<h3 class="fn" id="count-1"><span class="type">qsizetype</span> QByteArray::<span class="name">count</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the number of occurrences of byte <i>ch</i> in the byte array.</p>
<p><b>See also </b><a href="qbytearray.html#contains">contains</a>() and <a href="qbytearray.html#indexOf">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-2"><span class="type">qsizetype</span> QByteArray::<span class="name">count</span>() const</h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="qbytearray.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin"><code>[since 5.6] </code><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">crbegin</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first byte in the byte-array, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qbytearray.html#begin">begin</a>(), <a href="qbytearray.html#rbegin">rbegin</a>(), and <a href="qbytearray.html#rend">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend"><code>[since 5.6] </code><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">crend</span>() const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing just after the last byte in the byte-array, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qbytearray.html#end">end</a>(), <a href="qbytearray.html#rend">rend</a>(), and <a href="qbytearray.html#rbegin">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data"><span class="type">char</span> *QByteArray::<span class="name">data</span>()</h3>
<p>Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is '\0'-terminated, i.e&#x2e; the number of bytes you can access following the returned pointer is <a href="qbytearray.html#size">size</a>() + 1, including the '\0' terminator.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello world&quot;</span>);
 <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> ba<span class="operator">.</span>data();
 <span class="keyword">while</span> (<span class="operator">*</span>data) {
     cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;[&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>data <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;]&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
     <span class="operator">+</span><span class="operator">+</span>data;
 }
</pre>
<p>The pointer remains valid as long as no detach happens and the <a href="qbytearray.html">QByteArray</a> is not modified.</p>
<p>For read-only access, <a href="qbytearray.html#constData">constData</a>() is faster because it never causes a <a href="implicit-sharing.html#deep-copy">deep copy</a> to occur.</p>
<p>This function is mostly useful to pass a byte array to a function that accepts a <code>const char *</code>.</p>
<p>The following example makes a copy of the char* returned by data(), but it will corrupt the heap and cause a crash because it does not allocate a byte for the '\0' at the end:</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> tmp <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
 <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size()<span class="operator">]</span>;
 strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
 <span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;
</pre>
<p>This one allocates the correct amount of space:</p>
<pre class="cpp">
 <span class="type"><a href="qstring.html">QString</a></span> tmp <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
 <span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size() <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;
 strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
 <span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;
</pre>
<p>Note: A <a href="qbytearray.html">QByteArray</a> can store any byte values including '\0's, but most functions that take <code>char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>See also </b><a href="qbytearray.html#constData">constData</a>() and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" id="data-1">const <span class="type">char</span> *QByteArray::<span class="name">data</span>() const</h3>
<p>This is an overloaded function.</p>
<!-- @@@data -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end"><span class="type"><a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a></span> QByteArray::<span class="name">end</span>()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing just after the last byte in the byte-array.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#begin">begin</a>() and <a href="qbytearray.html#constEnd">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1"><span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> QByteArray::<span class="name">end</span>() const</h3>
<p>This function overloads end().</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithQByteArrayView -->
<h3 class="fn" id="endsWith"><code>[since 6.0] </code><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>Returns <code>true</code> if this byte array ends with the sequence of bytes viewed by <i>bv</i>; otherwise returns <code>false</code>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> url(<span class="string">&quot;http://qt-project.org/doc/qt-5.0/qtdoc/index.html&quot;</span>);
 <span class="keyword">if</span> (url<span class="operator">.</span>endsWith(<span class="string">&quot;.html&quot;</span>))
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#startsWith">startsWith</a>() and <a href="qbytearray.html#last">last</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithchar -->
<h3 class="fn" id="endsWith-1"><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if this byte array ends with byte <i>ch</i>; otherwise returns <code>false</code>.</p>
<!-- @@@endsWith -->
<!-- $$$erase[overload1]$$$eraseQByteArray::const_iteratorQByteArray::const_iterator -->
<h3 class="fn" id="erase"><code>[since 6.1] </code><span class="type"><a href="qbytearray.html#iterator-typedef">QByteArray::iterator</a></span> QByteArray::<span class="name">erase</span>(<span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> <i>first</i>, <span class="type"><a href="qbytearray.html#const_iterator-typedef">QByteArray::const_iterator</a></span> <i>last</i>)</h3>
<p>Removes from the byte array the characters in the half-open range [ <i>first</i> , <i>last</i> ). Returns an iterator to the character referred to by <i>last</i> before the erase.</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@erase -->
<!-- $$$fill[overload1]$$$fillcharqsizetype -->
<h3 class="fn" id="fill"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">fill</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>size</i> = -1)</h3>
<p>Sets every byte in the byte array to <i>ch</i>. If <i>size</i> is different from -1 (the default), the byte array is resized to size <i>size</i> beforehand.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Istambul&quot;</span>);
 ba<span class="operator">.</span>fill(<span class="char">'o'</span>);
 <span class="comment">// ba == &quot;oooooooo&quot;</span>

 ba<span class="operator">.</span>fill(<span class="char">'X'</span><span class="operator">,</span> <span class="number">2</span>);
 <span class="comment">// ba == &quot;XX&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#resize">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$first[overload1]$$$firstqsizetype -->
<h3 class="fn" id="first"><code>[since 6.0] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">first</span>(<span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns the first <i>n</i> bytes of the byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i>n</i> &lt; 0 or <i>n</i> &gt; <a href="qbytearray.html#size">size</a>().</p>
</div>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Pineapple&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>first(<span class="number">4</span>);
 <span class="comment">// y == &quot;Pine&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#sliced">sliced</a>(), <a href="qbytearray.html#startsWith">startsWith</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@first -->
<!-- $$$fromBase64[overload1]$$$fromBase64constQByteArray&QByteArray::Base64Options -->
<h3 class="fn" id="fromBase64"><code>[static, since 5.2] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromBase64</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>base64</i>, <span class="type"><a href="qbytearray.html#Base64Option-enum">QByteArray::Base64Options</a></span> <i>options</i> = Base64Encoding)</h3>
<p>Returns a decoded copy of the Base64 array <i>base64</i>, using the options defined by <i>options</i>. If <i>options</i> contains <code>IgnoreBase64DecodingErrors</code> (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If <i>options</i> contains <code>AbortOnBase64DecodingErrors</code>, then decoding will stop at the first invalid character.</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">&quot;UXQgaXMgZ3JlYXQh&quot;</span>);
 text<span class="operator">.</span>data();            <span class="comment">// returns &quot;Qt is great!&quot;</span>

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">&quot;PHA+SGVsbG8/PC9wPg==&quot;</span><span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64Encoding); <span class="comment">// returns &quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">&quot;PHA-SGVsbG8_PC9wPg==&quot;</span><span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding); <span class="comment">// returns &quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;</span>
</pre>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a>.</p>
<p>Returns the decoded data, or, if the <code>AbortOnBase64DecodingErrors</code> option was passed and the input data was invalid, an empty byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="qbytearray.html#fromBase64Encoding">fromBase64Encoding</a>() function is recommended in new code.</p>
</div>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="qbytearray.html#toBase64">toBase64</a>() and <a href="qbytearray.html#fromBase64Encoding">fromBase64Encoding</a>().</p>
<!-- @@@fromBase64 -->
<!-- $$$fromCFData[overload1]$$$fromCFDataCFDataRef -->
<h3 class="fn" id="fromCFData"><code>[static, since 5.3] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromCFData</span>(<span class="type">CFDataRef</span> <i>data</i>)</h3>
<p>Constructs a new <a href="qbytearray.html">QByteArray</a> containing a copy of the CFData <i>data</i>.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#fromRawCFData">fromRawCFData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toRawCFData">toRawCFData</a>(), and <a href="qbytearray.html#toCFData">toCFData</a>().</p>
<!-- @@@fromCFData -->
<!-- $$$fromHex[overload1]$$$fromHexconstQByteArray& -->
<h3 class="fn" id="fromHex"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromHex</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>hexEncoded</i>)</h3>
<p>Returns a decoded copy of the hex encoded array <i>hexEncoded</i>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromHex(<span class="string">&quot;517420697320677265617421&quot;</span>);
 text<span class="operator">.</span>data();            <span class="comment">// returns &quot;Qt is great!&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#toHex">toHex</a>().</p>
<!-- @@@fromHex -->
<!-- $$$fromNSData[overload1]$$$fromNSDataconstNSData* -->
<h3 class="fn" id="fromNSData"><code>[static, since 5.3] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromNSData</span>(const <span class="type">NSData</span> *<i>data</i>)</h3>
<p>Constructs a new <a href="qbytearray.html">QByteArray</a> containing a copy of the NSData <i>data</i>.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#fromRawNSData">fromRawNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toNSData">toNSData</a>(), and <a href="qbytearray.html#toRawNSData">toRawNSData</a>().</p>
<!-- @@@fromNSData -->
<!-- $$$fromPercentEncoding[overload1]$$$fromPercentEncodingconstQByteArray&char -->
<h3 class="fn" id="fromPercentEncoding"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromPercentEncoding</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>input</i>, <span class="type">char</span> <i>percent</i> = '%')</h3>
<p>Returns a decoded copy of the URI/URL-style percent-encoded <i>input</i>. The <i>percent</i> parameter allows you to replace the '%' character for another (for instance, '_' or '=').</p>
<p>For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromPercentEncoding(<span class="string">&quot;Qt%20is%20great%33&quot;</span>);
 text<span class="operator">.</span>data();            <span class="comment">// returns &quot;Qt is great!&quot;</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>Given invalid input (such as a string containing the sequence &quot;%G5&quot;, which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence &quot;%G5&quot; could be decoded to 'W'.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#toPercentEncoding">toPercentEncoding</a>() and <a href="qurl.html#fromPercentEncoding">QUrl::fromPercentEncoding</a>().</p>
<!-- @@@fromPercentEncoding -->
<!-- $$$fromRawCFData[overload1]$$$fromRawCFDataCFDataRef -->
<h3 class="fn" id="fromRawCFData"><code>[static, since 5.3] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromRawCFData</span>(<span class="type">CFDataRef</span> <i>data</i>)</h3>
<p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses the bytes of the CFData <i>data</i>.</p>
<p>The <i>data</i>'s bytes are not copied.</p>
<p>The caller guarantees that the CFData will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#fromCFData">fromCFData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toRawCFData">toRawCFData</a>(), and <a href="qbytearray.html#toCFData">toCFData</a>().</p>
<!-- @@@fromRawCFData -->
<!-- $$$fromRawData[overload1]$$$fromRawDataconstchar*qsizetype -->
<h3 class="fn" id="fromRawData"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses the first <i>size</i> bytes of the <i>data</i> array. The bytes are <i>not</i> copied. The <a href="qbytearray.html">QByteArray</a> will contain the <i>data</i> pointer. The caller guarantees that <i>data</i> will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> and any copies of it exist that have not been modified. In other words, because <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class and the instance returned by this function contains the <i>data</i> pointer, the caller must not delete <i>data</i> or modify it directly as long as the returned <a href="qbytearray.html">QByteArray</a> and any copies exist. However, <a href="qbytearray.html">QByteArray</a> does not take ownership of <i>data</i>, so the <a href="qbytearray.html">QByteArray</a> destructor will never delete the raw <i>data</i>, even when the last <a href="qbytearray.html">QByteArray</a> referring to <i>data</i> is destroyed.</p>
<p>A subsequent attempt to modify the contents of the returned <a href="qbytearray.html">QByteArray</a> or any copy made from it will cause it to create a deep copy of the <i>data</i> array before doing the modification. This ensures that the raw <i>data</i> array itself will never be modified by <a href="qbytearray.html">QByteArray</a>.</p>
<p>Here is an example of how to read data using a <a href="qdatastream.html">QDataStream</a> on raw data in memory without copying the raw data into a <a href="qbytearray.html">QByteArray</a>:</p>
<pre class="cpp">
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> mydata<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="char">'\x00'</span><span class="operator">,</span> <span class="char">'\x00'</span><span class="operator">,</span> <span class="char">'\x03'</span><span class="operator">,</span> <span class="char">'\x84'</span><span class="operator">,</span> <span class="char">'\x78'</span><span class="operator">,</span> <span class="char">'\x9c'</span><span class="operator">,</span> <span class="char">'\x3b'</span><span class="operator">,</span> <span class="char">'\x76'</span><span class="operator">,</span>
     <span class="char">'\xec'</span><span class="operator">,</span> <span class="char">'\x18'</span><span class="operator">,</span> <span class="char">'\xc3'</span><span class="operator">,</span> <span class="char">'\x31'</span><span class="operator">,</span> <span class="char">'\x0a'</span><span class="operator">,</span> <span class="char">'\xf1'</span><span class="operator">,</span> <span class="char">'\xcc'</span><span class="operator">,</span> <span class="char">'\x99'</span><span class="operator">,</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
     <span class="char">'\x6d'</span><span class="operator">,</span> <span class="char">'\x5b'</span>
 };

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> data <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromRawData(mydata<span class="operator">,</span> <span class="keyword">sizeof</span>(mydata));
 <span class="type"><a href="qdatastream.html">QDataStream</a></span> in(<span class="operator">&amp;</span>data<span class="operator">,</span> <span class="type"><a href="qiodevice.html">QIODevice</a></span><span class="operator">::</span>ReadOnly);
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<div class="admonition warning">
<p><b>Warning: </b>A byte array created with fromRawData() is <i>not</i> '\0'-terminated, unless the raw data contains a '\0' byte at position <i>size</i>. While that does not matter for <a href="qdatastream.html">QDataStream</a> or functions like <a href="qbytearray.html#indexOf">indexOf</a>(), passing the byte array to a function accepting a <code>const char *</code> expected to be '\0'-terminated will fail.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#setRawData">setRawData</a>(), <a href="qbytearray.html#data">data</a>(), and <a href="qbytearray.html#constData">constData</a>().</p>
<!-- @@@fromRawData -->
<!-- $$$fromRawNSData[overload1]$$$fromRawNSDataconstNSData* -->
<h3 class="fn" id="fromRawNSData"><code>[static, since 5.3] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromRawNSData</span>(const <span class="type">NSData</span> *<i>data</i>)</h3>
<p>Constructs a <a href="qbytearray.html">QByteArray</a> that uses the bytes of the NSData <i>data</i>.</p>
<p>The <i>data</i>'s bytes are not copied.</p>
<p>The caller guarantees that the NSData will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#fromNSData">fromNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#toRawNSData">toRawNSData</a>(), and <a href="qbytearray.html#toNSData">toNSData</a>().</p>
<!-- @@@fromRawNSData -->
<!-- $$$fromStdString[overload1]$$$fromStdStringconststd::string& -->
<h3 class="fn" id="fromStdString"><code>[static, since 5.4] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">fromStdString</span>(const <span class="type">std::string</span> &amp;<i>str</i>)</h3>
<p>Returns a copy of the <i>str</i> string as a <a href="qbytearray.html">QByteArray</a>.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="qbytearray.html#toStdString">toStdString</a>() and <a href="qstring.html#fromStdString">QString::fromStdString</a>().</p>
<!-- @@@fromStdString -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front"><code>[since 5.10] </code><span class="type">char</span> QByteArray::<span class="name">front</span>() const</h3>
<p>Returns the first byte in the byte array. Same as <code>at(0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qbytearray.html#back">back</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1"><code>[since 5.10] </code><span class="type">char</span> &amp;QByteArray::<span class="name">front</span>()</h3>
<p>Returns a reference to the first byte in the byte array. Same as <code>operator[](0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="qbytearray.html#back">back</a>(), <a href="qbytearray.html#at">at</a>(), and <a href="qbytearray.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfQByteArrayViewqsizetype -->
<h3 class="fn" id="indexOf"><code>[since 6.0] </code><span class="type">qsizetype</span> QByteArray::<span class="name">indexOf</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const</h3>
<p>Returns the index position of the start of the first occurrence of the sequence of bytes viewed by <i>bv</i> in this byte array, searching forward from index position <i>from</i>. Returns -1 if no match is found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;sticky question&quot;</span>);
 <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> y(<span class="string">&quot;sti&quot;</span>);
 x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
 x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a>(), <a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count-2">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfcharqsizetype -->
<h3 class="fn" id="indexOf-1"><span class="type">qsizetype</span> QByteArray::<span class="name">indexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = 0) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the start of the first occurrence of the byte <i>ch</i> in this byte array, searching forward from index position <i>from</i>. Returns -1 if no match is found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;ABCBA&quot;</span>);
 ba<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span>);            <span class="comment">// returns 1</span>
 ba<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">1</span>);         <span class="comment">// returns 1</span>
 ba<span class="operator">.</span>indexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">2</span>);         <span class="comment">// returns 3</span>
 ba<span class="operator">.</span>indexOf(<span class="string">&quot;X&quot;</span>);            <span class="comment">// returns -1</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#lastIndexOf">lastIndexOf</a>() and <a href="qbytearray.html#contains">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$insert[overload1]$$$insertqsizetypeQByteArrayView -->
<h3 class="fn" id="insert"><code>[since 6.0] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>data</i>)</h3>
<p>Inserts <i>data</i> at index position <i>i</i> and returns a reference to this byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Meal&quot;</span>);
 ba<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span>(<span class="string">&quot;ontr&quot;</span>));
 <span class="comment">// ba == &quot;Montreal&quot;</span>
</pre>
<p>For large byte arrays, this operation can be slow (<a href="containers.html#linear-time">linear time</a>), because it requires moving all the bytes at indexes <i>i</i> and above by at least one position further in memory.</p>
<p>This array grows to accommodate the insertion. If <i>i</i> is beyond the end of the array, the array is first extended with space characters to reach this <i>i</i>.</p>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#append">append</a>(), <a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeconstchar* -->
<h3 class="fn" id="insert-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type">char</span> *<i>s</i>)</h3>
<p>Inserts <i>s</i> at index position <i>i</i> and returns a reference to this byte array.</p>
<p>This array grows to accommodate the insertion. If <i>i</i> is beyond the end of the array, the array is first extended with space characters to reach this <i>i</i>.</p>
<p>The function is equivalent to <code>insert(i, QByteArrayView(s))</code></p>
<p><b>See also </b><a href="qbytearray.html#append">append</a>(), <a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeconstQByteArray& -->
<h3 class="fn" id="insert-2"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Inserts <i>data</i> at index position <i>i</i> and returns a reference to this byte array.</p>
<p>This array grows to accommodate the insertion. If <i>i</i> is beyond the end of the array, the array is first extended with space characters to reach this <i>i</i>.</p>
<p><b>See also </b><a href="qbytearray.html#append">append</a>(), <a href="qbytearray.html#prepend">prepend</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeqsizetypechar -->
<h3 class="fn" id="insert-3"><code>[since 5.7] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">qsizetype</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts <i>count</i> copies of byte <i>ch</i> at index position <i>i</i> in the byte array.</p>
<p>This array grows to accommodate the insertion. If <i>i</i> is beyond the end of the array, the array is first extended with space characters to reach this <i>i</i>.</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypechar -->
<h3 class="fn" id="insert-4"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts byte <i>ch</i> at index position <i>i</i> in the byte array.</p>
<p>This array grows to accommodate the insertion. If <i>i</i> is beyond the end of the array, the array is first extended with space characters to reach this <i>i</i>.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertqsizetypeconstchar*qsizetype -->
<h3 class="fn" id="insert-5"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">qsizetype</span> <i>i</i>, const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Inserts <i>len</i> bytes, starting at <i>data</i>, at position <i>i</i> in the byte array.</p>
<p>This array grows to accommodate the insertion. If <i>i</i> is beyond the end of the array, the array is first extended with space characters to reach this <i>i</i>.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty"><span class="type">bool</span> QByteArray::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code>true</code> if the byte array has size 0; otherwise returns <code>false</code>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isLower[overload1]$$$isLower -->
<h3 class="fn" id="isLower"><code>[since 5.12] </code><span class="type">bool</span> QByteArray::<span class="name">isLower</span>() const</h3>
<p>Returns <code>true</code> if this byte array contains only lowercase ASCII letters, otherwise returns <code>false</code>.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="qbytearray.html#isUpper">isUpper</a>() and <a href="qbytearray.html#toLower">toLower</a>().</p>
<!-- @@@isLower -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" id="isNull"><span class="type">bool</span> QByteArray::<span class="name">isNull</span>() const</h3>
<p>Returns <code>true</code> if this byte array is null; otherwise returns <code>false</code>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;&quot;</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;abc&quot;</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>
</pre>
<p>Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using <a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<p><b>See also </b><a href="qbytearray.html#isEmpty">isEmpty</a>().</p>
<!-- @@@isNull -->
<!-- $$$isUpper[overload1]$$$isUpper -->
<h3 class="fn" id="isUpper"><code>[since 5.12] </code><span class="type">bool</span> QByteArray::<span class="name">isUpper</span>() const</h3>
<p>Returns <code>true</code> if this byte array contains only ASCII uppercase letters, otherwise returns <code>false</code>.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="qbytearray.html#isLower">isLower</a>() and <a href="qbytearray.html#toUpper">toUpper</a>().</p>
<!-- @@@isUpper -->
<!-- $$$last[overload1]$$$lastqsizetype -->
<h3 class="fn" id="last"><code>[since 6.0] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">last</span>(<span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns the last <i>n</i> bytes of the byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i>n</i> &lt; 0 or <i>n</i> &gt; <a href="qbytearray.html#size">size</a>().</p>
</div>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Pineapple&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>last(<span class="number">5</span>);
 <span class="comment">// y == &quot;apple&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#sliced">sliced</a>(), <a href="qbytearray.html#endsWith">endsWith</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@last -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfQByteArrayViewqsizetype -->
<h3 class="fn" id="lastIndexOf"><code>[since 6.0] </code><span class="type">qsizetype</span> QByteArray::<span class="name">lastIndexOf</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>, <span class="type">qsizetype</span> <i>from</i>) const</h3>
<p>Returns the index position of the start of the last occurrence of the sequence of bytes viewed by <i>bv</i> in this byte array, searching backward from index position <i>from</i>. If <i>from</i> is -1, the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if no match is found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;crazy azimuths&quot;</span>);
 <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> y(<span class="string">&quot;az&quot;</span>);
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>When searching for a 0-length <i>bv</i>, the match at the end of the data is excluded from the search by a negative <i>from</i>, even though <code>-1</code> is normally thought of as searching from the end of the byte array: the match at the end is <i>after</i> the last character, so it is excluded. To include such a final empty match, either give a positive value for <i>from</i> or omit the <i>from</i> parameter entirely.</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#indexOf">indexOf</a>(), <a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count-2">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfcharqsizetype -->
<h3 class="fn" id="lastIndexOf-1"><span class="type">qsizetype</span> QByteArray::<span class="name">lastIndexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">qsizetype</span> <i>from</i> = -1) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the start of the last occurrence of byte <i>ch</i> in this byte array, searching backward from index position <i>from</i>. If <i>from</i> is -1 (the default), the search starts at the last byte (at index <a href="qbytearray.html#size">size</a>() - 1). Returns -1 if no match is found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;ABCBA&quot;</span>);
 ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span>);        <span class="comment">// returns 3</span>
 ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">3</span>);     <span class="comment">// returns 3</span>
 ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="number">2</span>);     <span class="comment">// returns 1</span>
 ba<span class="operator">.</span>lastIndexOf(<span class="string">&quot;X&quot;</span>);        <span class="comment">// returns -1</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#indexOf">indexOf</a>() and <a href="qbytearray.html#contains">contains</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfQByteArrayView -->
<h3 class="fn" id="lastIndexOf-2"><code>[since 6.2] </code><span class="type">qsizetype</span> QByteArray::<span class="name">lastIndexOf</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the start of the last occurrence of the sequence of bytes viewed by <i>bv</i> in this byte array, searching backward from the end of the byte array. Returns -1 if no match is found.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;crazy azimuths&quot;</span>);
 <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> y(<span class="string">&quot;az&quot;</span>);
 x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
 x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span>
</pre>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qbytearray.html#indexOf">indexOf</a>(), <a href="qbytearray.html#contains">contains</a>(), and <a href="qbytearray.html#count-2">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$left[overload1]$$$leftqsizetype -->
<h3 class="fn" id="left"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">left</span>(<span class="type">qsizetype</span> <i>len</i>) const</h3>
<p>Returns a byte array that contains the first <i>len</i> bytes of this byte array.</p>
<p>If you know that <i>len</i> cannot be out of bounds, use <a href="qbytearray.html#first">first</a>() instead in new code, because it is faster.</p>
<p>The entire byte array is returned if <i>len</i> is greater than <a href="qbytearray.html#size">size</a>().</p>
<p>Returns an empty <a href="qbytearray.html">QByteArray</a> if <i>len</i> is smaller than 0.</p>
<p><b>See also </b><a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#startsWith">startsWith</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@left -->
<!-- $$$leftJustified[overload1]$$$leftJustifiedqsizetypecharbool -->
<h3 class="fn" id="leftJustified"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">leftJustified</span>(<span class="type">qsizetype</span> <i>width</i>, <span class="type">char</span> <i>fill</i> = ' ', <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a byte array of size <i>width</i> that contains this byte array padded with the <i>fill</i> byte.</p>
<p>If <i>truncate</i> is false and the <a href="qbytearray.html#size">size</a>() of the byte array is more than <i>width</i>, then the returned byte array is a copy of this byte array.</p>
<p>If <i>truncate</i> is true and the <a href="qbytearray.html#size">size</a>() of the byte array is more than <i>width</i>, then any bytes in a copy of the byte array after position <i>width</i> are removed, and the copy is returned.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;apple&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>leftJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);   <span class="comment">// y == &quot;apple...&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#rightJustified">rightJustified</a>().</p>
<!-- @@@leftJustified -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length"><span class="type">qsizetype</span> QByteArray::<span class="name">length</span>() const</h3>
<p>Same as <a href="qbytearray.html#size">size</a>().</p>
<!-- @@@length -->
<!-- $$$mid[overload1]$$$midqsizetypeqsizetype -->
<h3 class="fn" id="mid"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">mid</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>len</i> = -1) const</h3>
<p>Returns a byte array containing <i>len</i> bytes from this byte array, starting at position <i>pos</i>.</p>
<p>If you know that <i>pos</i> and <i>len</i> cannot be out of bounds, use <a href="qbytearray.html#sliced">sliced</a>() instead in new code, because it is faster.</p>
<p>If <i>len</i> is -1 (the default), or <i>pos</i> + <i>len</i> &gt;= <a href="qbytearray.html#size">size</a>(), returns a byte array containing all bytes starting at position <i>pos</i> until the end of the byte array.</p>
<p><b>See also </b><a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#sliced">sliced</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@mid -->
<!-- $$$number[overload1]$$$numberintint -->
<h3 class="fn" id="number"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Returns a byte-array representing the whole number <i>n</i> as text.</p>
<p>Returns a byte array containing a string representing <i>n</i>, using the specified <i>base</i> (ten by default). Bases 2 through 36 are supported, using letters for digits beyond 9: A is ten, B is eleven and so on.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(n);              <span class="comment">// returns &quot;63&quot;</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(n<span class="operator">,</span> <span class="number">16</span>);          <span class="comment">// returns &quot;3f&quot;</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(n<span class="operator">,</span> <span class="number">16</span>)<span class="operator">.</span>toUpper();  <span class="comment">// returns &quot;3F&quot;</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#setNum">setNum</a>() and <a href="qbytearray.html#toInt">toInt</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberuintint -->
<h3 class="fn" id="number-1"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toUInt">toUInt</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberlongint -->
<h3 class="fn" id="number-2"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">long</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toLong">toLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberulongint -->
<h3 class="fn" id="number-3"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toULong">toULong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberqlonglongint -->
<h3 class="fn" id="number-4"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toLongLong">toLongLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberqulonglongint -->
<h3 class="fn" id="number-5"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toULongLong">toULongLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberdoublecharint -->
<h3 class="fn" id="number-6"><code>[static] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte-array representing the floating-point number <i>n</i> as text.</p>
<p>Returns a byte array containing a string representing <i>n</i>, with a given <i>format</i> and <i>precision</i>, with the same meanings as for <a href="qstring.html#number-6">QString::number</a>(double, char, int). For example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>number(<span class="number">12.3456</span><span class="operator">,</span> <span class="char">'E'</span><span class="operator">,</span> <span class="number">3</span>);
 <span class="comment">// ba == 1.235E+01</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#toDouble">toDouble</a>() and <a href="qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a>.</p>
<!-- @@@number -->
<!-- $$$prepend[overload1]$$$prependQByteArrayView -->
<h3 class="fn" id="prepend"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>ba</i>)</h3>
<p>Prepends the byte array view <i>ba</i> to this byte array and returns a reference to this byte array.</p>
<p>This operation is typically very fast (<a href="containers.html#constant-time">constant time</a>), because <a href="qbytearray.html">QByteArray</a> preallocates extra space at the beginning of the data, so it can grow without reallocating the entire array each time.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;ship&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;air&quot;</span>);
 x<span class="operator">.</span>prepend(y);
 <span class="comment">// x == &quot;airship&quot;</span>
</pre>
<p>This is the same as insert(0, <i>ba</i>).</p>
<p><b>See also </b><a href="qbytearray.html#append">append</a>() and <a href="qbytearray.html#insert">insert</a>().</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependchar -->
<h3 class="fn" id="prepend-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends the byte <i>ch</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependqsizetypechar -->
<h3 class="fn" id="prepend-2"><code>[since 5.7] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type">qsizetype</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends <i>count</i> copies of byte <i>ch</i> to this byte array.</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar* -->
<h3 class="fn" id="prepend-3"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends the '\0'-terminated string <i>str</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar*qsizetype -->
<h3 class="fn" id="prepend-4"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends <i>len</i> bytes starting at <i>str</i> to this byte array. The bytes prepended may include '\0' bytes.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstQByteArray& -->
<h3 class="fn" id="prepend-5"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>This is an overloaded function.</p>
<p>Prepends <i>ba</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$push_back[overload1]$$$push_backconstQByteArray& -->
<h3 class="fn" id="push_back"><span class="type">void</span> QByteArray::<span class="name">push_back</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility. It is equivalent to append(<i>other</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backchar -->
<h3 class="fn" id="push_back-1"><span class="type">void</span> QByteArray::<span class="name">push_back</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i>ch</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backconstchar* -->
<h3 class="fn" id="push_back-2"><span class="type">void</span> QByteArray::<span class="name">push_back</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i>str</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backQByteArrayView -->
<h3 class="fn" id="push_back-3"><code>[since 6.0] </code><span class="type">void</span> QByteArray::<span class="name">push_back</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i>str</i>).</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@push_back -->
<!-- $$$push_front[overload1]$$$push_frontconstQByteArray& -->
<h3 class="fn" id="push_front"><span class="type">void</span> QByteArray::<span class="name">push_front</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>This function is provided for STL compatibility. It is equivalent to prepend(<i>other</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontchar -->
<h3 class="fn" id="push_front-1"><span class="type">void</span> QByteArray::<span class="name">push_front</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i>ch</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontconstchar* -->
<h3 class="fn" id="push_front-2"><span class="type">void</span> QByteArray::<span class="name">push_front</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i>str</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontQByteArrayView -->
<h3 class="fn" id="push_front-3"><code>[since 6.0] </code><span class="type">void</span> QByteArray::<span class="name">push_front</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i>str</i>).</p>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@push_front -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin"><code>[since 5.6] </code><span class="type"><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a></span> QByteArray::<span class="name">rbegin</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing to the first byte in the byte-array, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qbytearray.html#begin">begin</a>(), <a href="qbytearray.html#crbegin">crbegin</a>(), and <a href="qbytearray.html#rend">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1"><code>[since 5.6] </code><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">rbegin</span>() const</h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeqsizetypeqsizetype -->
<h3 class="fn" id="remove"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">remove</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>len</i>)</h3>
<p>Removes <i>len</i> bytes from the array, starting at index position <i>pos</i>, and returns a reference to the array.</p>
<p>If <i>pos</i> is out of range, nothing happens. If <i>pos</i> is valid, but <i>pos</i> + <i>len</i> is larger than the size of the array, the array is truncated at position <i>pos</i>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Montreal&quot;</span>);
 ba<span class="operator">.</span>remove(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
 <span class="comment">// ba == &quot;Meal&quot;</span>
</pre>
<p>Element removal will preserve the array's capacity and not reduce the amount of allocated memory. To shed extra capacity and free as much memory as possible, call <a href="qbytearray.html#squeeze">squeeze</a>() after the last change to the array's size.</p>
<p><b>See also </b><a href="qbytearray.html#insert">insert</a>(), <a href="qbytearray.html#replace">replace</a>(), and <a href="qbytearray.html#squeeze">squeeze</a>().</p>
<!-- @@@remove -->
<!-- $$$removeIf[overload1]$$$removeIfPredicate -->
<h3 class="fn" id="removeIf"><code>[since 6.1] </code>template &lt;typename Predicate&gt; <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">removeIf</span>(<span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all bytes for which the predicate <i>pred</i> returns true from the byte array. Returns a reference to the byte array.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@removeIf -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend"><code>[since 5.6] </code><span class="type"><a href="qbytearray.html#reverse_iterator-typedef">QByteArray::reverse_iterator</a></span> QByteArray::<span class="name">rend</span>()</h3>
<p>Returns a <a href="containers.html#stl-style-iterators">STL-style</a> reverse iterator pointing just after the last byte in the byte-array, in reverse order.</p>
<div class="admonition warning">
<p><b>Warning: </b>The returned iterator is invalidated on detachment or when the <a href="qbytearray.html">QByteArray</a> is modified.</p>
</div>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="qbytearray.html#end">end</a>(), <a href="qbytearray.html#crend">crend</a>(), and <a href="qbytearray.html#rbegin">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1"><code>[since 5.6] </code><span class="type"><a href="qbytearray.html#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">rend</span>() const</h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rend -->
<!-- $$$repeated[overload1]$$$repeatedqsizetype -->
<h3 class="fn" id="repeated"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">repeated</span>(<span class="type">qsizetype</span> <i>times</i>) const</h3>
<p>Returns a copy of this byte array repeated the specified number of <i>times</i>.</p>
<p>If <i>times</i> is less than 1, an empty byte array is returned.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;ab&quot;</span>);
 ba<span class="operator">.</span>repeated(<span class="number">4</span>);             <span class="comment">// returns &quot;abababab&quot;</span>
</pre>
<!-- @@@repeated -->
<!-- $$$replace[overload1]$$$replaceqsizetypeqsizetypeQByteArrayView -->
<h3 class="fn" id="replace"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>len</i>, <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>after</i>)</h3>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with the byte array <i>after</i>, and returns a reference to this byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Say yes!&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;no&quot;</span>);
 x<span class="operator">.</span>replace(<span class="number">4</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> y);
 <span class="comment">// x == &quot;Say no!&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#insert">insert</a>() and <a href="qbytearray.html#remove">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceqsizetypeqsizetypeconstchar*qsizetype -->
<h3 class="fn" id="replace-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>len</i>, const <span class="type">char</span> *<i>after</i>, <span class="type">qsizetype</span> <i>alen</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces <i>len</i> bytes from index position <i>pos</i> with <i>alen</i> bytes starting at position <i>after</i>. The bytes inserted may include '\0' bytes.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharQByteArrayView -->
<h3 class="fn" id="replace-2"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte <i>before</i> with the byte array <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*qsizetypeconstchar*qsizetype -->
<h3 class="fn" id="replace-3"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, <span class="type">qsizetype</span> <i>bsize</i>, const <span class="type">char</span> *<i>after</i>, <span class="type">qsizetype</span> <i>asize</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the <i>bsize</i> bytes starting at <i>before</i> with the <i>asize</i> bytes starting at <i>after</i>. Since the sizes of the strings are given by <i>bsize</i> and <i>asize</i>, they may contain '\0' bytes and do not need to be '\0'-terminated.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceQByteArrayViewQByteArrayView -->
<h3 class="fn" id="replace-4"><code>[since 6.0] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>before</i>, <span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte array <i>before</i> with the byte array <i>after</i>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;colour behaviour flavour neighbour&quot;</span>);
 ba<span class="operator">.</span>replace(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;ou&quot;</span>)<span class="operator">,</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>(<span class="string">&quot;o&quot;</span>));
 <span class="comment">// ba == &quot;color behavior flavor neighbor&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharchar -->
<h3 class="fn" id="replace-5"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, <span class="type">char</span> <i>after</i>)</h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte <i>before</i> with the byte <i>after</i>.</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveqsizetype -->
<h3 class="fn" id="reserve"><span class="type">void</span> QByteArray::<span class="name">reserve</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Attempts to allocate memory for at least <i>size</i> bytes.</p>
<p>If you know in advance how large the byte array will be, you can call this function, and if you call <a href="qbytearray.html#resize">resize</a>() often you are likely to get better performance.</p>
<p>If in doubt about how much space shall be needed, it is usually better to use an upper bound as <i>size</i>, or a high estimate of the most likely size, if a strict upper bound would be much bigger than this. If <i>size</i> is an underestimate, the array will grow as needed once the reserved size is exceeded, which may lead to a larger allocation than your best overestimate would have and will slow the operation that triggers it.</p>
<div class="admonition warning">
<p><b>Warning: </b>reserve() reserves memory but does not change the size of the byte array. Accessing data beyond the end of the byte array is undefined behavior. If you need to access memory beyond the current end of the array, use <a href="qbytearray.html#resize">resize</a>().</p>
</div>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="qbytearray.html#squeeze">squeeze</a>() and <a href="qbytearray.html#capacity">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeqsizetype -->
<h3 class="fn" id="resize"><span class="type">void</span> QByteArray::<span class="name">resize</span>(<span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Sets the size of the byte array to <i>size</i> bytes.</p>
<p>If <i>size</i> is greater than the current size, the byte array is extended to make it <i>size</i> bytes with the extra bytes added to the end. The new bytes are uninitialized.</p>
<p>If <i>size</i> is less than the current size, bytes beyond position <i>size</i> are excluded from the byte array.</p>
<div class="admonition note">
<p><b>Note: </b>While resize() will grow the capacity if needed, it never shrinks capacity. To shed excess capacity, use <a href="qbytearray.html#squeeze">squeeze</a>().</p>
</div>
<p><b>See also </b><a href="qbytearray.html#size">size</a>(), <a href="qbytearray.html#truncate">truncate</a>(), and <a href="qbytearray.html#squeeze">squeeze</a>().</p>
<!-- @@@resize -->
<!-- $$$right[overload1]$$$rightqsizetype -->
<h3 class="fn" id="right"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">right</span>(<span class="type">qsizetype</span> <i>len</i>) const</h3>
<p>Returns a byte array that contains the last <i>len</i> bytes of this byte array.</p>
<p>If you know that <i>len</i> cannot be out of bounds, use <a href="qbytearray.html#last">last</a>() instead in new code, because it is faster.</p>
<p>The entire byte array is returned if <i>len</i> is greater than <a href="qbytearray.html#size">size</a>().</p>
<p>Returns an empty <a href="qbytearray.html">QByteArray</a> if <i>len</i> is smaller than 0.</p>
<p><b>See also </b><a href="qbytearray.html#endsWith">endsWith</a>(), <a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#sliced">sliced</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@right -->
<!-- $$$rightJustified[overload1]$$$rightJustifiedqsizetypecharbool -->
<h3 class="fn" id="rightJustified"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">rightJustified</span>(<span class="type">qsizetype</span> <i>width</i>, <span class="type">char</span> <i>fill</i> = ' ', <span class="type">bool</span> <i>truncate</i> = false) const</h3>
<p>Returns a byte array of size <i>width</i> that contains the <i>fill</i> byte followed by this byte array.</p>
<p>If <i>truncate</i> is false and the size of the byte array is more than <i>width</i>, then the returned byte array is a copy of this byte array.</p>
<p>If <i>truncate</i> is true and the size of the byte array is more than <i>width</i>, then the resulting byte array is truncated at position <i>width</i>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;apple&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>rightJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// y == &quot;...apple&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#leftJustified">leftJustified</a>().</p>
<!-- @@@rightJustified -->
<!-- $$$setNum[overload1]$$$setNumintint -->
<h3 class="fn" id="setNum"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>Represent the whole number <i>n</i> as text.</p>
<p>Sets this byte array to a string representing <i>n</i> in base <i>base</i> (ten by default) and returns a reference to this byte array. Bases 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba;
 <span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
 ba<span class="operator">.</span>setNum(n);           <span class="comment">// ba == &quot;63&quot;</span>
 ba<span class="operator">.</span>setNum(n<span class="operator">,</span> <span class="number">16</span>);       <span class="comment">// ba == &quot;3f&quot;</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>() and <a href="qbytearray.html#toInt">toInt</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumshortint -->
<h3 class="fn" id="setNum-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">short</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toShort">toShort</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumushortint -->
<h3 class="fn" id="setNum-2"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toUShort">toUShort</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumuintint -->
<h3 class="fn" id="setNum-3"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toUInt">toUInt</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumlongint -->
<h3 class="fn" id="setNum-4"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">long</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toLong">toLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumulongint -->
<h3 class="fn" id="setNum-5"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toULong">toULong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqlonglongint -->
<h3 class="fn" id="setNum-6"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toLongLong">toLongLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqulonglongint -->
<h3 class="fn" id="setNum-7"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)</h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="qbytearray.html#toULongLong">toULongLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumfloatcharint -->
<h3 class="fn" id="setNum-8"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">float</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Represent the floating-point number <i>n</i> as text.</p>
<p>Sets this byte array to a string representing <i>n</i>, with a given <i>format</i> and <i>precision</i> (with the same meanings as for <a href="qstring.html#number-6">QString::number</a>(double, char, int)), and returns a reference to this byte array.</p>
<p><b>See also </b><a href="qbytearray.html#toFloat">toFloat</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumdoublecharint -->
<h3 class="fn" id="setNum-9"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>format</i> = 'g', <span class="type">int</span> <i>precision</i> = 6)</h3>
<p>This is an overloaded function.</p>
<p>Represent the floating-point number <i>n</i> as text.</p>
<p>Sets this byte array to a string representing <i>n</i>, with a given <i>format</i> and <i>precision</i> (with the same meanings as for <a href="qstring.html#number-6">QString::number</a>(double, char, int)), and returns a reference to this byte array.</p>
<p><b>See also </b><a href="qbytearray.html#toDouble">toDouble</a>() and <a href="qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a>.</p>
<!-- @@@setNum -->
<!-- $$$setRawData[overload1]$$$setRawDataconstchar*qsizetype -->
<h3 class="fn" id="setRawData"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">setRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>size</i>)</h3>
<p>Resets the <a href="qbytearray.html">QByteArray</a> to use the first <i>size</i> bytes of the <i>data</i> array. The bytes are <i>not</i> copied. The <a href="qbytearray.html">QByteArray</a> will contain the <i>data</i> pointer. The caller guarantees that <i>data</i> will not be deleted or modified as long as this <a href="qbytearray.html">QByteArray</a> and any copies of it exist that have not been modified.</p>
<p>This function can be used instead of <a href="qbytearray.html#fromRawData">fromRawData</a>() to re-use existing <a href="qbytearray.html">QByteArray</a> objects to save memory re-allocations.</p>
<p><b>See also </b><a href="qbytearray.html#fromRawData">fromRawData</a>(), <a href="qbytearray.html#data">data</a>(), and <a href="qbytearray.html#constData">constData</a>().</p>
<!-- @@@setRawData -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" id="shrink_to_fit"><code>[since 5.10] </code><span class="type">void</span> QByteArray::<span class="name">shrink_to_fit</span>()</h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="qbytearray.html#squeeze">squeeze</a>().</p>
<p>This function was introduced in Qt 5.10.</p>
<!-- @@@shrink_to_fit -->
<!-- $$$simplified[overload1]$$$simplified -->
<h3 class="fn" id="simplified"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">simplified</span>() const</h3>
<p>Returns a copy of this byte array that has spacing characters removed from the start and end, and in which each sequence of internal spacing characters is replaced with a single space.</p>
<p>The spacing characters are those for which the standard C++ <code>isspace()</code> function returns <code>true</code> in the C locale; these are the ASCII characters tabulation '\t', line feed '\n', carriage return '\r', vertical tabulation '\v', form feed '\f', and space ' '.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>);
 ba <span class="operator">=</span> ba<span class="operator">.</span>simplified();
 <span class="comment">// ba == &quot;lots of whitespace&quot;;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#trimmed">trimmed</a>(), <a href="qchar.html#SpecialCharacter-enum">QChar::SpecialCharacter</a>, and <a href="qbytearray.html#spacing-characters">Spacing Characters</a>.</p>
<!-- @@@simplified -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><span class="type">qsizetype</span> QByteArray::<span class="name">size</span>() const</h3>
<p>Returns the number of bytes in this byte array.</p>
<p>The last byte in the byte array is at position size() - 1. In addition, <a href="qbytearray.html">QByteArray</a> ensures that the byte at position size() is always '\0', so that you can use the return value of <a href="qbytearray.html#data">data</a>() and <a href="qbytearray.html#constData">constData</a>() as arguments to functions that expect '\0'-terminated strings. If the <a href="qbytearray.html">QByteArray</a> object was created from a <a href="qbytearray.html#fromRawData">raw data</a> that didn't include the trailing '\0'-termination byte, then <a href="qbytearray.html">QByteArray</a> doesn't add it automatically unless a <a href="implicit-sharing.html#deep-copy">deep copy</a> is created.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello&quot;</span>);
 qsizetype n <span class="operator">=</span> ba<span class="operator">.</span>size();    <span class="comment">// n == 5</span>
 ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;               <span class="comment">// returns 'H'</span>
 ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;               <span class="comment">// returns 'o'</span>
 ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">5</span><span class="operator">]</span>;               <span class="comment">// returns '\0'</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#isEmpty">isEmpty</a>() and <a href="qbytearray.html#resize">resize</a>().</p>
<!-- @@@size -->
<!-- $$$sliced[overload1]$$$slicedqsizetypeqsizetype -->
<h3 class="fn" id="sliced"><code>[since 6.0] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>, <span class="type">qsizetype</span> <i>n</i>) const</h3>
<p>Returns a byte array containing the <i>n</i> bytes of this object starting at position <i>pos</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i>pos</i> &lt; 0, <i>n</i> &lt; 0, or <i>pos</i> + <i>n</i> &gt; <a href="qbytearray.html#size">size</a>().</p>
</div>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Five pineapples&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>sliced(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);     <span class="comment">// y == &quot;pine&quot;</span>
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> z <span class="operator">=</span> x<span class="operator">.</span>sliced(<span class="number">5</span>);        <span class="comment">// z == &quot;pineapples&quot;</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@sliced -->
<!-- $$$sliced$$$slicedqsizetype -->
<h3 class="fn" id="sliced-1"><code>[since 6.0] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">sliced</span>(<span class="type">qsizetype</span> <i>pos</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array containing the bytes starting at position <i>pos</i> in this object, and extending to the end of this object.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined when <i>pos</i> &lt; 0 or <i>pos</i> &gt; <a href="qbytearray.html#size">size</a>().</p>
</div>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#first">first</a>(), <a href="qbytearray.html#last">last</a>(), <a href="qbytearray.html#sliced">sliced</a>(), <a href="qbytearray.html#chopped">chopped</a>(), <a href="qbytearray.html#chop">chop</a>(), and <a href="qbytearray.html#truncate">truncate</a>().</p>
<!-- @@@sliced -->
<!-- $$$split[overload1]$$$splitchar -->
<h3 class="fn" id="split"><span class="type"><a href="qlist.html">QList</a></span>&lt;<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span>&gt; QByteArray::<span class="name">split</span>(<span class="type">char</span> <i>sep</i>) const</h3>
<p>Splits the byte array into subarrays wherever <i>sep</i> occurs, and returns the list of those arrays. If <i>sep</i> does not match anywhere in the byte array, split() returns a single-element list containing this byte array.</p>
<!-- @@@split -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze"><span class="type">void</span> QByteArray::<span class="name">squeeze</span>()</h3>
<p>Releases any memory not required to store the array's data.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qbytearray.html">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="qbytearray.html#reserve">reserve</a>() and <a href="qbytearray.html#capacity">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithQByteArrayView -->
<h3 class="fn" id="startsWith"><code>[since 6.0] </code><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>bv</i>) const</h3>
<p>Returns <code>true</code> if this byte array starts with the sequence of bytes viewed by <i>bv</i>; otherwise returns <code>false</code>.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> url(<span class="string">&quot;ftp://ftp.qt-project.org/&quot;</span>);
 <span class="keyword">if</span> (url<span class="operator">.</span>startsWith(<span class="string">&quot;ftp:&quot;</span>))
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
</pre>
<p>This function was introduced in Qt 6.0.</p>
<p><b>See also </b><a href="qbytearray.html#endsWith">endsWith</a>() and <a href="qbytearray.html#first">first</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithchar -->
<h3 class="fn" id="startsWith-1"><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(<span class="type">char</span> <i>ch</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if this byte array starts with byte <i>ch</i>; otherwise returns <code>false</code>.</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQByteArray& -->
<h3 class="fn" id="swap"><span class="type">void</span> QByteArray::<span class="name">swap</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>other</i>)</h3>
<p>Swaps byte array <i>other</i> with this byte array. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$toBase64[overload1]$$$toBase64QByteArray::Base64Options -->
<h3 class="fn" id="toBase64"><code>[since 5.2] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toBase64</span>(<span class="type"><a href="qbytearray.html#Base64Option-enum">QByteArray::Base64Options</a></span> <i>options</i> = Base64Encoding) const</h3>
<p>Returns a copy of the byte array, encoded using the options <i>options</i>.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text(<span class="string">&quot;Qt is great!&quot;</span>);
 text<span class="operator">.</span>toBase64();        <span class="comment">// returns &quot;UXQgaXMgZ3JlYXQh&quot;</span>

 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text(<span class="string">&quot;&lt;p&gt;Hello?&lt;/p&gt;&quot;</span>);
 text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64Encoding <span class="operator">|</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>OmitTrailingEquals);      <span class="comment">// returns &quot;PHA+SGVsbG8/PC9wPg&quot;</span>
 text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64Encoding);                                       <span class="comment">// returns &quot;PHA+SGVsbG8/PC9wPg==&quot;</span>
 text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding);                                    <span class="comment">// returns &quot;PHA-SGVsbG8_PC9wPg==&quot;</span>
 text<span class="operator">.</span>toBase64(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding <span class="operator">|</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>OmitTrailingEquals);   <span class="comment">// returns &quot;PHA-SGVsbG8_PC9wPg&quot;</span>
</pre>
<p>The algorithm used to encode Base64-encoded data is defined in <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="qbytearray.html#fromBase64">fromBase64</a>().</p>
<!-- @@@toBase64 -->
<!-- $$$toCFData[overload1]$$$toCFData -->
<h3 class="fn" id="toCFData"><code>[since 5.3] </code><span class="type">CFDataRef</span> QByteArray::<span class="name">toCFData</span>() const</h3>
<p>Creates a CFData from a <a href="qbytearray.html">QByteArray</a>.</p>
<p>The caller owns the CFData object and is responsible for releasing it.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#toRawCFData">toRawCFData</a>(), <a href="qbytearray.html#fromCFData">fromCFData</a>(), <a href="qbytearray.html#fromRawCFData">fromRawCFData</a>(), and <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@toCFData -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" id="toDouble"><span class="type">double</span> QByteArray::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the byte array converted to a <code>double</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g&#x2e; underflow).</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> string(<span class="string">&quot;1234.56&quot;</span>);
 bool ok;
 <span class="type">double</span> a <span class="operator">=</span> string<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);   <span class="comment">// a == 1234.56, ok == true</span>

 string <span class="operator">=</span> <span class="string">&quot;1234.56 Volt&quot;</span>;
 a <span class="operator">=</span> str<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);             <span class="comment">// a == 0, ok == false</span>
</pre>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qbytearray.html">QByteArray</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function ignores leading and trailing whitespace.</p>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" id="toFloat"><span class="type">float</span> QByteArray::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const</h3>
<p>Returns the byte array converted to a <code>float</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g&#x2e; underflow).</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> string(<span class="string">&quot;1234.56&quot;</span>);
 bool ok;
 <span class="type">float</span> a <span class="operator">=</span> string<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);    <span class="comment">// a == 1234.56, ok == true</span>

 string <span class="operator">=</span> <span class="string">&quot;1234.56 Volt&quot;</span>;
 a <span class="operator">=</span> str<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);              <span class="comment">// a == 0, ok == false</span>
</pre>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="qbytearray.html">QByteArray</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p>This function ignores leading and trailing whitespace.</p>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toHex[overload1]$$$toHexchar -->
<h3 class="fn" id="toHex"><code>[since 5.9] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toHex</span>(<span class="type">char</span> <i>separator</i> = '\0') const</h3>
<p>Returns a hex encoded copy of the byte array.</p>
<p>The hex encoding uses the numbers 0-9 and the letters a-f.</p>
<p>If <i>separator</i> is not '\0', the separator character is inserted between the hex bytes.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> macAddress <span class="operator">=</span> <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span><span class="operator">::</span>fromHex(<span class="string">&quot;123456abcdef&quot;</span>);
 macAddress<span class="operator">.</span>toHex(<span class="char">':'</span>); <span class="comment">// returns &quot;12:34:56:ab:cd:ef&quot;</span>
 macAddress<span class="operator">.</span>toHex(<span class="number">0</span>);   <span class="comment">// returns &quot;123456abcdef&quot;</span>
</pre>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="qbytearray.html#fromHex">fromHex</a>().</p>
<!-- @@@toHex -->
<!-- $$$toInt[overload1]$$$toIntbool*int -->
<h3 class="fn" id="toInt"><span class="type">int</span> QByteArray::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>int</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> str(<span class="string">&quot;FF&quot;</span>);
 bool ok;
 <span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
 <span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toInt -->
<!-- $$$toLong[overload1]$$$toLongbool*int -->
<h3 class="fn" id="toLong"><span class="type">long</span> QByteArray::<span class="name">toLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to a <code>long</code> int using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> str(<span class="string">&quot;FF&quot;</span>);
 bool ok;
 <span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
 <span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span>
</pre>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toLong -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool*int -->
<h3 class="fn" id="toLongLong"><span class="type"><a href="qtglobal.html#qlonglong-typedef">qlonglong</a></span> QByteArray::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to a <code>long long</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toLongLong -->
<!-- $$$toLower[overload1]$$$toLower -->
<h3 class="fn" id="toLower"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toLower</span>() const</h3>
<p>Returns a copy of the byte array in which each ASCII uppercase letter converted to lowercase.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Qt by THE QT COMPANY&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toLower();
 <span class="comment">// y == &quot;qt by the qt company&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#isLower">isLower</a>(), <a href="qbytearray.html#toUpper">toUpper</a>(), and <a href="qbytearray.html#character-case">Character Case</a>.</p>
<!-- @@@toLower -->
<!-- $$$toNSData[overload1]$$$toNSData -->
<h3 class="fn" id="toNSData"><code>[since 5.3] </code><span class="type">NSData</span> *QByteArray::<span class="name">toNSData</span>() const</h3>
<p>Creates a NSData from a <a href="qbytearray.html">QByteArray</a>.</p>
<p>The NSData object is autoreleased.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#fromNSData">fromNSData</a>(), <a href="qbytearray.html#fromRawNSData">fromRawNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), and <a href="qbytearray.html#toRawNSData">toRawNSData</a>().</p>
<!-- @@@toNSData -->
<!-- $$$toPercentEncoding[overload1]$$$toPercentEncodingconstQByteArray&constQByteArray&char -->
<h3 class="fn" id="toPercentEncoding"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toPercentEncoding</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>exclude</i> = QByteArray(), const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>include</i> = QByteArray(), <span class="type">char</span> <i>percent</i> = '%') const</h3>
<p>Returns a URI/URL-style percent-encoded copy of this byte array. The <i>percent</i> parameter allows you to override the default '%' character for another.</p>
<p>By default, this function will encode all bytes that are not one of the following:</p>
<p>ALPHA (&quot;a&quot; to &quot;z&quot; and &quot;A&quot; to &quot;Z&quot;) / DIGIT (0 to 9) / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</p>
<p>To prevent bytes from being encoded pass them to <i>exclude</i>. To force bytes to be encoded pass them to <i>include</i>. The <i>percent</i> character is always encoded.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> text <span class="operator">=</span> <span class="string">&quot;{a fishy string?}&quot;</span>;
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba <span class="operator">=</span> text<span class="operator">.</span>toPercentEncoding(<span class="string">&quot;{}&quot;</span><span class="operator">,</span> <span class="string">&quot;s&quot;</span>);
 <a href="qtglobal.html#qDebug">qDebug</a>(ba<span class="operator">.</span>constData());
 <span class="comment">// prints &quot;{a fi%73hy %73tring%3F}&quot;</span>
</pre>
<p>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</p>
<p><b>See also </b><a href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</a>() and <a href="qurl.html#toPercentEncoding">QUrl::toPercentEncoding</a>().</p>
<!-- @@@toPercentEncoding -->
<!-- $$$toRawCFData[overload1]$$$toRawCFData -->
<h3 class="fn" id="toRawCFData"><code>[since 5.3] </code><span class="type">CFDataRef</span> QByteArray::<span class="name">toRawCFData</span>() const</h3>
<p>Constructs a CFData that uses the bytes of the <a href="qbytearray.html">QByteArray</a>.</p>
<p>The <a href="qbytearray.html">QByteArray</a>'s bytes are not copied.</p>
<p>The caller guarantees that the <a href="qbytearray.html">QByteArray</a> will not be deleted or modified as long as this CFData object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#toCFData">toCFData</a>(), <a href="qbytearray.html#fromRawCFData">fromRawCFData</a>(), <a href="qbytearray.html#fromCFData">fromCFData</a>(), and <a href="qbytearray.html#fromRawData">fromRawData</a>().</p>
<!-- @@@toRawCFData -->
<!-- $$$toRawNSData[overload1]$$$toRawNSData -->
<h3 class="fn" id="toRawNSData"><code>[since 5.3] </code><span class="type">NSData</span> *QByteArray::<span class="name">toRawNSData</span>() const</h3>
<p>Constructs a NSData that uses the bytes of the <a href="qbytearray.html">QByteArray</a>.</p>
<p>The <a href="qbytearray.html">QByteArray</a>'s bytes are not copied.</p>
<p>The caller guarantees that the <a href="qbytearray.html">QByteArray</a> will not be deleted or modified as long as this NSData object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="qbytearray.html#fromRawNSData">fromRawNSData</a>(), <a href="qbytearray.html#fromNSData">fromNSData</a>(), <a href="qbytearray.html#fromRawData">fromRawData</a>(), and <a href="qbytearray.html#toNSData">toNSData</a>().</p>
<!-- @@@toRawNSData -->
<!-- $$$toShort[overload1]$$$toShortbool*int -->
<h3 class="fn" id="toShort"><span class="type">short</span> QByteArray::<span class="name">toShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to a <code>short</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; otherwise, if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toShort -->
<!-- $$$toStdString[overload1]$$$toStdString -->
<h3 class="fn" id="toStdString"><code>[since 5.4] </code><span class="type">std::string</span> QByteArray::<span class="name">toStdString</span>() const</h3>
<p>Returns a std::string object with the data contained in this <a href="qbytearray.html">QByteArray</a>.</p>
<p>This operator is mostly useful to pass a <a href="qbytearray.html">QByteArray</a> to a function that accepts a std::string object.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="qbytearray.html#fromStdString">fromStdString</a>() and <a href="qstring.html#toStdString">QString::toStdString</a>().</p>
<!-- @@@toStdString -->
<!-- $$$toUInt[overload1]$$$toUIntbool*int -->
<h3 class="fn" id="toUInt"><span class="type"><a href="qtglobal.html#uint-typedef">uint</a></span> QByteArray::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned int</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toUInt -->
<!-- $$$toULong[overload1]$$$toULongbool*int -->
<h3 class="fn" id="toULong"><span class="type"><a href="qtglobal.html#ulong-typedef">ulong</a></span> QByteArray::<span class="name">toULong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned long int</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toULong -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool*int -->
<h3 class="fn" id="toULongLong"><span class="type"><a href="qtglobal.html#qulonglong-typedef">qulonglong</a></span> QByteArray::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned long long</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal (base 16); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal (base 8); otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toULongLong -->
<!-- $$$toUShort[overload1]$$$toUShortbool*int -->
<h3 class="fn" id="toUShort"><span class="type"><a href="qtglobal.html#ushort-typedef">ushort</a></span> QByteArray::<span class="name">toUShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const</h3>
<p>Returns the byte array converted to an <code>unsigned short</code> using base <i>base</i>, which is ten by default. Bases 0 and 2 through 36 are supported, using letters for digits beyond 9; A is ten, B is eleven and so on.</p>
<p>If <i>base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal; otherwise, if it begins with &quot;0&quot;, it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i>ok</i> is not <code>nullptr</code>, failure is reported by setting *<i>ok</i> to <code>false</code>, and success by setting *<i>ok</i> to <code>true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, regardless of the user's locale. Use <a href="qlocale.html">QLocale</a> to perform locale-aware conversions between numbers and strings.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#number">number</a>().</p>
<!-- @@@toUShort -->
<!-- $$$toUpper[overload1]$$$toUpper -->
<h3 class="fn" id="toUpper"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">toUpper</span>() const</h3>
<p>Returns a copy of the byte array in which each ASCII lowercase letter converted to uppercase.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;Qt by THE QT COMPANY&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toUpper();
 <span class="comment">// y == &quot;QT BY THE QT COMPANY&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#isUpper">isUpper</a>(), <a href="qbytearray.html#toLower">toLower</a>(), and <a href="qbytearray.html#character-case">Character Case</a>.</p>
<!-- @@@toUpper -->
<!-- $$$trimmed[overload1]$$$trimmed -->
<h3 class="fn" id="trimmed"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> QByteArray::<span class="name">trimmed</span>() const</h3>
<p>Returns a copy of this byte array with spacing characters removed from the start and end.</p>
<p>The spacing characters are those for which the standard C++ <code>isspace()</code> function returns <code>true</code> in the C locale; these are the ASCII characters tabulation '\t', line feed '\n', carriage return '\r', vertical tabulation '\v', form feed '\f', and space ' '.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;  lots\t of\nwhitespace\r\n &quot;</span>);
 ba <span class="operator">=</span> ba<span class="operator">.</span>trimmed();
 <span class="comment">// ba == &quot;lots\t of\nwhitespace&quot;;</span>
</pre>
<p>Unlike <a href="qbytearray.html#simplified">simplified</a>(), trimmed() leaves internal spacing unchanged.</p>
<p><b>See also </b><a href="qbytearray.html#simplified">simplified</a>(), <a href="qchar.html#SpecialCharacter-enum">QChar::SpecialCharacter</a>, and <a href="qbytearray.html#spacing-characters">Spacing Characters</a>.</p>
<!-- @@@trimmed -->
<!-- $$$truncate[overload1]$$$truncateqsizetype -->
<h3 class="fn" id="truncate"><span class="type">void</span> QByteArray::<span class="name">truncate</span>(<span class="type">qsizetype</span> <i>pos</i>)</h3>
<p>Truncates the byte array at index position <i>pos</i>.</p>
<p>If <i>pos</i> is beyond the end of the array, nothing happens.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Stockholm&quot;</span>);
 ba<span class="operator">.</span>truncate(<span class="number">5</span>);             <span class="comment">// ba == &quot;Stock&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#chop">chop</a>(), <a href="qbytearray.html#resize">resize</a>(), and <a href="qbytearray.html#first">first</a>().</p>
<!-- @@@truncate -->
<!-- $$$operator!=[overload1]$$$operator!=constQString& -->
<h3 class="fn" id="operator-not-eq"><span class="type">bool</span> QByteArray::<span class="name">operator!=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is not equal to the UTF-8 encoding of <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator!= -->
<!-- $$$operator+=[overload1]$$$operator+=constQByteArray& -->
<h3 class="fn" id="operator-2b-eq"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Appends the byte array <i>ba</i> onto the end of this byte array and returns a reference to this byte array.</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> x(<span class="string">&quot;free&quot;</span>);
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> y(<span class="string">&quot;dom&quot;</span>);
 x <span class="operator">+</span><span class="operator">=</span> y;
 <span class="comment">// x == &quot;freedom&quot;</span>
</pre>
<p>Note: <a href="qbytearray.html">QByteArray</a> is an <a href="implicit-sharing.html">implicitly shared</a> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <i>ba</i>. In this case, no copying of data is done, taking <a href="containers.html#constant-time">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <a href="containers.html#linear-time">linear time</a>.</p>
<p>This operation typically does not suffer from allocation overhead, because <a href="qbytearray.html">QByteArray</a> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</p>
<p><b>See also </b><a href="qbytearray.html#append">append</a>() and <a href="qbytearray.html#prepend">prepend</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=char -->
<h3 class="fn" id="operator-2b-eq-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(<span class="type">char</span> <i>ch</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the byte <i>ch</i> onto the end of this byte array and returns a reference to this byte array.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constchar* -->
<h3 class="fn" id="operator-2b-eq-2"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Appends the '\0'-terminated string <i>str</i> onto the end of this byte array and returns a reference to this byte array.</p>
<!-- @@@operator+= -->
<!-- $$$operator<[overload1]$$$operator<constQString& -->
<h3 class="fn" id="operator-lt"><span class="type">bool</span> QByteArray::<span class="name">operator&lt;</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is lexically less than the UTF-8 encoding of <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator< -->
<!-- $$$operator<=[overload1]$$$operator<=constQString& -->
<h3 class="fn" id="operator-lt-eq"><span class="type">bool</span> QByteArray::<span class="name">operator&lt;=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is lexically less than or equal to the UTF-8 encoding of <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator<= -->
<!-- $$$operator=$$$operator=constchar* -->
<h3 class="fn" id="operator-eq-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>This is an overloaded function.</p>
<p>Assigns <i>str</i> to this byte array.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQString& -->
<h3 class="fn" id="operator-eq-eq"><span class="type">bool</span> QByteArray::<span class="name">operator==</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is equal to the UTF-8 encoding of <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator== -->
<!-- $$$operator>[overload1]$$$operator>constQString& -->
<h3 class="fn" id="operator-gt"><span class="type">bool</span> QByteArray::<span class="name">operator&gt;</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is lexically greater than the UTF-8 encoding of <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQString& -->
<h3 class="fn" id="operator-gt-eq"><span class="type">bool</span> QByteArray::<span class="name">operator&gt;=</span>(const <span class="type"><a href="qstring.html">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code>true</code> if this byte array is greater than or equal to the UTF-8 encoding of <i>str</i>; otherwise returns <code>false</code>.</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code>QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="qstring.html#fromUtf8">QString::fromUtf8</a>(), <a href="qstring.html#fromLatin1">QString::fromLatin1</a>(), or <a href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="qstring.html">QString</a> before doing the comparison.</p>
<!-- @@@operator>= -->
<!-- $$$operator[][overload1]$$$operator[]qsizetype -->
<h3 class="fn" id="operator-5b-5d"><span class="type">char</span> &amp;QByteArray::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>)</h3>
<p>Returns the byte at index position <i>i</i> as a modifiable reference.</p>
<p><i>i</i> must be a valid index position in the byte array (i.e&#x2e;, 0 &lt;= <i>i</i> &lt; <a href="qbytearray.html#size">size</a>()).</p>
<p>Example:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba(<span class="string">&quot;Hello, world&quot;</span>);
 cout <span class="operator">&lt;</span><span class="operator">&lt;</span> ba<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>; <span class="comment">// prints H</span>
 ba<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">=</span> <span class="char">'W'</span>;
 <span class="comment">// ba == &quot;Hello, World&quot;</span>
</pre>
<p><b>See also </b><a href="qbytearray.html#at">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]qsizetype -->
<h3 class="fn" id="operator-5b-5d-1"><span class="type">char</span> QByteArray::<span class="name">operator[]</span>(<span class="type">qsizetype</span> <i>i</i>) const</h3>
<p>This is an overloaded function.</p>
<p>Same as at(<i>i</i>).</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$erase$$$eraseQByteArray&constT& -->
<h3 class="fn" id="erase-1"><code>[since 6.1] </code>template &lt;typename T&gt; <span class="type">qsizetype</span> <span class="name">erase</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>, const <span class="type">T</span> &amp;<i>t</i>)</h3>
<p>Removes all elements that compare equal to <i>t</i> from the byte array <i>ba</i>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qbytearray.html#erase_if">erase_if</a>.</p>
<!-- @@@erase -->
<!-- $$$erase_if[overload1]$$$erase_ifQByteArray&Predicate -->
<h3 class="fn" id="erase_if"><code>[since 6.1] </code>template &lt;typename Predicate&gt; <span class="type">qsizetype</span> <span class="name">erase_if</span>(<span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>, <span class="type">Predicate</span> <i>pred</i>)</h3>
<p>Removes all elements for which the predicate <i>pred</i> returns true from the byte array <i>ba</i>. Returns the number of elements removed, if any.</p>
<p>This function was introduced in Qt 6.1.</p>
<p><b>See also </b><a href="qbytearray.html#erase">erase</a>.</p>
<!-- @@@erase_if -->
<!-- $$$qChecksum[overload1]$$$qChecksumQByteArrayViewQt::ChecksumType -->
<h3 class="fn" id="qChecksum"><code>[since 5.9] </code><span class="type"><a href="qtglobal.html#quint16-typedef">quint16</a></span> <span class="name">qChecksum</span>(<span class="type"><a href="qbytearrayview.html">QByteArrayView</a></span> <i>data</i>, <span class="type"><a href="qt.html#ChecksumType-enum">Qt::ChecksumType</a></span> <i>standard</i> = Qt::ChecksumIso3309)</h3>
<p>Returns the CRC-16 checksum of <i>data</i>.</p>
<p>The checksum is independent of the byte order (endianness) and will be calculated accorded to the algorithm published in <i>standard</i>. By default the algorithm published in ISO 3309 (<a href="qt.html#ChecksumType-enum">Qt::ChecksumIso3309</a>) is used.</p>
<div class="admonition note">
<p><b>Note: </b>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</p>
</div>
<p>This function was introduced in Qt 5.9.</p>
<!-- @@@qChecksum -->
<!-- $$$qCompress[overload1]$$$qCompressconstQByteArray&int -->
<h3 class="fn" id="qCompress"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qCompress</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>data</i>, <span class="type">int</span> <i>compressionLevel</i> = -1)</h3>
<p>Compresses the <i>data</i> byte array and returns the compressed data in a new byte array.</p>
<p>The <i>compressionLevel</i> parameter specifies how much compression should be used. Valid values are between 0 and 9, with 9 corresponding to the greatest compression (i.e&#x2e; smaller compressed data) at the cost of using a slower algorithm. Smaller values (8, 7, ..&#x2e;, 1) provide successively less compression at slightly faster speeds. The value 0 corresponds to no compression at all. The default value is -1, which specifies zlib's default compression.</p>
<p><b>See also </b><a href="qbytearray.html#qUncompress-1">qUncompress</a>(const QByteArray &amp;data).</p>
<!-- @@@qCompress -->
<!-- $$$qCompress$$$qCompressconstuchar*qsizetypeint -->
<h3 class="fn" id="qCompress-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qCompress</span>(const <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>nbytes</i>, <span class="type">int</span> <i>compressionLevel</i> = -1)</h3>
<p>This is an overloaded function.</p>
<p>Compresses the first <i>nbytes</i> of <i>data</i> at compression level <i>compressionLevel</i> and returns the compressed data in a new byte array.</p>
<!-- @@@qCompress -->
<!-- $$$qUncompress$$$qUncompressconstQByteArray& -->
<h3 class="fn" id="qUncompress-1"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qUncompress</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Uncompresses the <i>data</i> byte array and returns a new byte array with the uncompressed data.</p>
<p>Returns an empty <a href="qbytearray.html">QByteArray</a> if the input data was corrupt.</p>
<p>This function will uncompress data compressed with <a href="qbytearray.html#qCompress">qCompress</a>() from this and any earlier Qt version, back to Qt 3.1 when this feature was added.</p>
<p><b>Note:</b> If you want to use this function to uncompress external data that was compressed using zlib, you first need to prepend a four byte header to the byte array containing the data. The header must contain the expected length (in bytes) of the uncompressed data, expressed as an unsigned, big-endian, 32-bit integer.</p>
<p><b>See also </b><a href="qbytearray.html#qCompress">qCompress</a>().</p>
<!-- @@@qUncompress -->
<!-- $$$qUncompress$$$qUncompressconstuchar*qsizetype -->
<h3 class="fn" id="qUncompress-2"><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">qUncompress</span>(const <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>nbytes</i>)</h3>
<p>This is an overloaded function.</p>
<p>Uncompresses the first <i>nbytes</i> of <i>data</i> and returns a new byte array with the uncompressed data.</p>
<!-- @@@qUncompress -->
<!-- $$$qsnprintf[overload1]$$$qsnprintfchar*size_tconstchar*... -->
<h3 class="fn" id="qsnprintf"><span class="type">int</span> <span class="name">qsnprintf</span>(<span class="type">char</span> *<i>str</i>, <span class="type">size_t</span> <i>n</i>, const <span class="type">char</span> *<i>fmt</i>, ...)</h3>
<span id="bytearray-qsnprintf"></span><p>A portable snprintf() function, calls qvsnprintf.</p>
<p><i>fmt</i> is the <code>printf()</code> format string. The result is put into <i>str</i>, which is a buffer of at least <i>n</i> bytes.</p>
<div class="admonition warning">
<p><b>Warning: </b>Call this function only when you know what you are doing since it shows different behavior on certain platforms. Use <a href="qstring.html#asprintf">QString::asprintf</a>() to format a string instead.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#qvsnprintf">qvsnprintf</a>() and <a href="qstring.html#asprintf">QString::asprintf</a>().</p>
<!-- @@@qsnprintf -->
<!-- $$$qstrcmp[overload1]$$$qstrcmpconstchar*constchar* -->
<h3 class="fn" id="qstrcmp"><span class="type">int</span> <span class="name">qstrcmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>)</h3>
<p>A safe <code>strcmp()</code> function.</p>
<p>Compares <i>str1</i> and <i>str2</i>. Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>If both strings are <code>nullptr</code>, they are deemed equal; otherwise, if either is <code>nullptr</code>, it is treated as less than the other (even if the other is an empty string).</p>
<p><b>See also </b><a href="qbytearray.html#qstrncmp">qstrncmp</a>(), <a href="qbytearray.html#qstricmp">qstricmp</a>(), <a href="qbytearray.html#qstrnicmp">qstrnicmp</a>(), <a href="qbytearray.html#character-case">Character Case</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstrcmp -->
<!-- $$$qstrcpy[overload1]$$$qstrcpychar*constchar* -->
<h3 class="fn" id="qstrcpy"><span class="type">char</span> *<span class="name">qstrcpy</span>(<span class="type">char</span> *<i>dst</i>, const <span class="type">char</span> *<i>src</i>)</h3>
<p>Copies all the characters up to and including the '\0' from <i>src</i> into <i>dst</i> and returns a pointer to <i>dst</i>. If <i>src</i> is <code>nullptr</code>, it immediately returns <code>nullptr</code>.</p>
<p>This function assumes that <i>dst</i> is large enough to hold the contents of <i>src</i>.</p>
<div class="admonition note">
<p><b>Note: </b>If <i>dst</i> and <i>src</i> overlap, the behavior is undefined.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#qstrncpy">qstrncpy</a>().</p>
<!-- @@@qstrcpy -->
<!-- $$$qstrdup[overload1]$$$qstrdupconstchar* -->
<h3 class="fn" id="qstrdup"><span class="type">char</span> *<span class="name">qstrdup</span>(const <span class="type">char</span> *<i>src</i>)</h3>
<p>Returns a duplicate string.</p>
<p>Allocates space for a copy of <i>src</i>, copies it, and returns a pointer to the copy. If <i>src</i> is <code>nullptr</code>, it immediately returns <code>nullptr</code>.</p>
<p>Ownership is passed to the caller, so the returned string must be deleted using <code>delete[]</code>.</p>
<!-- @@@qstrdup -->
<!-- $$$qstricmp[overload1]$$$qstricmpconstchar*constchar* -->
<h3 class="fn" id="qstricmp"><span class="type">int</span> <span class="name">qstricmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>)</h3>
<p>A safe <code>stricmp()</code> function.</p>
<p>Compares <i>str1</i> and <i>str2</i>, ignoring differences in the case of any ASCII characters.</p>
<p>Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>If both strings are <code>nullptr</code>, they are deemed equal; otherwise, if either is <code>nullptr</code>, it is treated as less than the other (even if the other is an empty string).</p>
<p><b>See also </b><a href="qbytearray.html#qstrcmp">qstrcmp</a>(), <a href="qbytearray.html#qstrncmp">qstrncmp</a>(), <a href="qbytearray.html#qstrnicmp">qstrnicmp</a>(), <a href="qbytearray.html#character-case">Character Case</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstricmp -->
<!-- $$$qstrlen[overload1]$$$qstrlenconstchar* -->
<h3 class="fn" id="qstrlen"><span class="type">size_t</span> <span class="name">qstrlen</span>(const <span class="type">char</span> *<i>str</i>)</h3>
<p>A safe <code>strlen()</code> function.</p>
<p>Returns the number of characters that precede the terminating '\0', or 0 if <i>str</i> is <code>nullptr</code>.</p>
<p><b>See also </b><a href="qbytearray.html#qstrnlen">qstrnlen</a>().</p>
<!-- @@@qstrlen -->
<!-- $$$qstrncmp[overload1]$$$qstrncmpconstchar*constchar*size_t -->
<h3 class="fn" id="qstrncmp"><span class="type">int</span> <span class="name">qstrncmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>, <span class="type">size_t</span> <i>len</i>)</h3>
<p>A safe <code>strncmp()</code> function.</p>
<p>Compares at most <i>len</i> bytes of <i>str1</i> and <i>str2</i>.</p>
<p>Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>If both strings are <code>nullptr</code>, they are deemed equal; otherwise, if either is <code>nullptr</code>, it is treated as less than the other (even if the other is an empty string or <i>len</i> is 0).</p>
<p><b>See also </b><a href="qbytearray.html#qstrcmp">qstrcmp</a>(), <a href="qbytearray.html#qstricmp">qstricmp</a>(), <a href="qbytearray.html#qstrnicmp">qstrnicmp</a>(), <a href="qbytearray.html#character-case">Character Case</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstrncmp -->
<!-- $$$qstrncpy[overload1]$$$qstrncpychar*constchar*size_t -->
<h3 class="fn" id="qstrncpy"><span class="type">char</span> *<span class="name">qstrncpy</span>(<span class="type">char</span> *<i>dst</i>, const <span class="type">char</span> *<i>src</i>, <span class="type">size_t</span> <i>len</i>)</h3>
<p>A safe <code>strncpy()</code> function.</p>
<p>Copies at most <i>len</i> bytes from <i>src</i> (stopping at <i>len</i> or the terminating '\0' whichever comes first) into <i>dst</i> and returns a pointer to <i>dst</i>. Guarantees that <i>dst</i> is '\0'-terminated. If <i>src</i> or <i>dst</i> is <code>nullptr</code>, returns <code>nullptr</code> immediately.</p>
<p>This function assumes that <i>dst</i> is at least <i>len</i> characters long.</p>
<div class="admonition note">
<p><b>Note: </b>If <i>dst</i> and <i>src</i> overlap, the behavior is undefined.</p>
</div>
<p><b>See also </b><a href="qbytearray.html#qstrcpy">qstrcpy</a>().</p>
<!-- @@@qstrncpy -->
<!-- $$$qstrnicmp[overload1]$$$qstrnicmpconstchar*constchar*size_t -->
<h3 class="fn" id="qstrnicmp"><span class="type">int</span> <span class="name">qstrnicmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>, <span class="type">size_t</span> <i>len</i>)</h3>
<p>A safe <code>strnicmp()</code> function.</p>
<p>Compares at most <i>len</i> bytes of <i>str1</i> and <i>str2</i>, ignoring differences in the case of any ASCII characters.</p>
<p>Returns a negative value if <i>str1</i> is less than <i>str2</i>, 0 if <i>str1</i> is equal to <i>str2</i> or a positive value if <i>str1</i> is greater than <i>str2</i>.</p>
<p>If both strings are <code>nullptr</code>, they are deemed equal; otherwise, if either is <code>nullptr</code>, it is treated as less than the other (even if the other is an empty string or <i>len</i> is 0).</p>
<p><b>See also </b><a href="qbytearray.html#qstrcmp">qstrcmp</a>(), <a href="qbytearray.html#qstrncmp">qstrncmp</a>(), <a href="qbytearray.html#qstricmp">qstricmp</a>(), <a href="qbytearray.html#character-case">Character Case</a>, and <a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@qstrnicmp -->
<!-- $$$qstrnlen[overload1]$$$qstrnlenconstchar*size_t -->
<h3 class="fn" id="qstrnlen"><span class="type">size_t</span> <span class="name">qstrnlen</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">size_t</span> <i>maxlen</i>)</h3>
<p>A safe <code>strnlen()</code> function.</p>
<p>Returns the number of characters that precede the terminating '\0', but at most <i>maxlen</i>. If <i>str</i> is <code>nullptr</code>, returns 0.</p>
<p><b>See also </b><a href="qbytearray.html#qstrlen">qstrlen</a>().</p>
<!-- @@@qstrnlen -->
<!-- $$$qvsnprintf[overload1]$$$qvsnprintfchar*size_tconstchar*va_list -->
<h3 class="fn" id="qvsnprintf"><span class="type">int</span> <span class="name">qvsnprintf</span>(<span class="type">char</span> *<i>str</i>, <span class="type">size_t</span> <i>n</i>, const <span class="type">char</span> *<i>fmt</i>, <span class="type">va_list</span> <i>ap</i>)</h3>
<p>A portable <code>vsnprintf()</code> function. Will call <code>::vsnprintf()</code>, <code>::_vsnprintf()</code>, or <code>::vsnprintf_s</code> depending on the system, or fall back to an internal version.</p>
<p><i>fmt</i> is the <code>printf()</code> format string. The result is put into <i>str</i>, which is a buffer of at least <i>n</i> bytes.</p>
<p>The caller is responsible to call <code>va_end()</code> on <i>ap</i>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Since vsnprintf() shows different behavior on certain platforms, you should not rely on the return value or on the fact that you will always get a 0 terminated string back.</p>
</div>
<p>Ideally, you should never call this function but use <a href="qstring.html#asprintf">QString::asprintf</a>() instead.</p>
<p><b>See also </b><a href="qbytearray.html#qsnprintf">qsnprintf</a>() and <a href="qstring.html#asprintf">QString::asprintf</a>().</p>
<!-- @@@qvsnprintf -->
<!-- $$$operator!=$$$operator!=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-not-eq-1"><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is not equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQByteArray&constchar* -->
<h3 class="fn" id="operator-not-eq-2"><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is not equal to the '\0'-terminated string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constchar*constQByteArray& -->
<h3 class="fn" id="operator-not-eq-3"><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if '\0'-terminated string <i>a1</i> is not equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator""_qba[overload1]$$$operator""_qbaconstchar*size_t -->
<h3 class="fn" id="operator-22-22_qba"><code>[since 6.2] </code><span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator&quot;&quot;_qba</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">size_t</span> <i>size</i>)</h3>
<p>Literal operator that creates a <a href="qbytearray.html">QByteArray</a> out of the first <i>size</i> characters in the char string literal <i>str</i>.</p>
<p>The <a href="qbytearray.html">QByteArray</a> is created at compile time, and the generated string data is stored in the read-only segment of the compiled object file. Duplicate literals may share the same read-only memory. This functionality is interchangeable with <a href="qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a>, but saves typing when many string literals are present in the code.</p>
<p>The following code creates a <a href="qbytearray.html">QByteArray</a>:</p>
<pre class="cpp">
 <span class="keyword">auto</span> str <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>_qba;
</pre>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a> and <a href="qstring.html#operator-22-22_qs">QtLiterals::operator&quot;&quot;_qs</a>(const char16_t *str, size_t size).</p>
<!-- @@@operator""_qba -->
<!-- $$$operator+[overload1]$$$operator+constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-2b">const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>Returns a byte array that is the result of concatenating byte array <i>a1</i> and byte array <i>a2</i>.</p>
<p><b>See also </b><a href="qbytearray.html#operator-2b-eq">QByteArray::operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQByteArray&constchar* -->
<h3 class="fn" id="operator-2b-1">const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte array <i>a1</i> and '\0'-terminated string <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQByteArray&char -->
<h3 class="fn" id="operator-2b-2">const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, <span class="type">char</span> <i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte array <i>a1</i> and byte <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constchar*constQByteArray& -->
<h3 class="fn" id="operator-2b-3">const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating '\0'-terminated string <i>a1</i> and byte array <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+charconstQByteArray& -->
<h3 class="fn" id="operator-2b-4">const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> <span class="name">operator+</span>(<span class="type">char</span> <i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte <i>a1</i> and byte array <i>a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator<$$$operator<constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-lt-1"><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constQByteArray&constchar* -->
<h3 class="fn" id="operator-lt-2"><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than the '\0'-terminated string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constchar*constQByteArray& -->
<h3 class="fn" id="operator-lt-3"><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if '\0'-terminated string <i>a1</i> is lexically less than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQByteArray& -->
<h3 class="fn" id="operator-lt-lt"><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Writes byte array <i>ba</i> to the stream <i>out</i> and returns a reference to the stream.</p>
<p><b>See also </b><a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<=$$$operator<=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-1"><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constQByteArray&constchar* -->
<h3 class="fn" id="operator-lt-eq-2"><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically less than or equal to the '\0'-terminated string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constchar*constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-3"><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if '\0'-terminated string <i>a1</i> is lexically less than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator==$$$operator==constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-1"><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQByteArray&constchar* -->
<h3 class="fn" id="operator-eq-eq-2"><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is equal to the '\0'-terminated string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constchar*constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-3"><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if '\0'-terminated string <i>a1</i> is equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator>$$$operator>constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-gt-1"><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constQByteArray&constchar* -->
<h3 class="fn" id="operator-gt-2"><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than the '\0'-terminated string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constchar*constQByteArray& -->
<h3 class="fn" id="operator-gt-3"><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if '\0'-terminated string <i>a1</i> is lexically greater than byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>=$$$operator>=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-1"><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constQByteArray&constchar* -->
<h3 class="fn" id="operator-gt-eq-2"><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if byte array <i>a1</i> is lexically greater than or equal to the '\0'-terminated string <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constchar*constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-3"><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>a2</i>)</h3>
<p>This is an overloaded function.</p>
<p>Returns <code>true</code> if '\0'-terminated string <i>a1</i> is lexically greater than or equal to byte array <i>a2</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qbytearray.html#compare">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QByteArray& -->
<h3 class="fn" id="operator-gt-gt"><span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream.html">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> &amp;<i>ba</i>)</h3>
<p>Reads a byte array into <i>ba</i> from the stream <i>in</i> and returns a reference to the stream.</p>
<p><b>See also </b><a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QByteArrayLiteral[overload1]$$$QByteArrayLiteral -->
<h3 class="fn" id="QByteArrayLiteral"><span class="name">QByteArrayLiteral</span>(<i>ba</i>)</h3>
<p>The macro generates the data for a <a href="qbytearray.html">QByteArray</a> out of the string literal <i>ba</i> at compile time. Creating a <a href="qbytearray.html">QByteArray</a> from it is free in this case, and the generated byte array data is stored in the read-only segment of the compiled object file.</p>
<p>For instance:</p>
<pre class="cpp">
 <span class="type"><a href="qbytearray.html#QByteArray">QByteArray</a></span> ba <span class="operator">=</span> <span class="type">QByteArrayLiteral</span>(<span class="string">&quot;byte array contents&quot;</span>);
</pre>
<p>Using QByteArrayLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of <a href="qbytearray.html">QByteArray</a> instances from data known at compile time.</p>
<p><b>See also </b><a href="qstring.html#QStringLiteral">QStringLiteral</a>.</p>
<!-- @@@QByteArrayLiteral -->
<!-- $$$QT_NO_CAST_FROM_BYTEARRAY[overload1]$$$QT_NO_CAST_FROM_BYTEARRAY -->
<h3 class="fn" id="QT_NO_CAST_FROM_BYTEARRAY"><span class="name">QT_NO_CAST_FROM_BYTEARRAY</span></h3>
<p>Disables automatic conversions from <a href="qbytearray.html">QByteArray</a> to const char * or const void *.</p>
<p><b>See also </b><a href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a> and <a href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>.</p>
<!-- @@@QT_NO_CAST_FROM_BYTEARRAY -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
