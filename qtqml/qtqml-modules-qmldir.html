<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmldir.qdoc -->
  <title>Module Definition qmldir Files | Qt QML 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtqml-index.html">Qt QML</a></li>
<li>Module Definition qmldir Files</li>
<li id="buildversion"><a href="qtqml-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#contents-of-a-module-definition-qmldir-file">Contents of a Module Definition qmldir File</a></li>
<li class="level1"><a href="#versioning-semantics">Versioning Semantics</a></li>
<li class="level1"><a href="#example-of-a-qmldir-file">Example of a qmldir File</a></li>
<li class="level1"><a href="#type-description-files">Type Description Files</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Module Definition qmldir Files</h1>
<!-- $$$qtqml-modules-qmldir.html-description -->
<div class="descr" id="details">
<p>There are two distinct types of <code>qmldir</code> files:</p>
<ul>
<li>QML document directory listing files</li>
<li>QML module definition files</li>
</ul>
<p>This documentation covers only the second form of <code>qmldir</code> file, which lists the QML types, JavaScript files, and plugins that are available under a module. For more information about the first form of <code>qmldir</code> file, see <a href="qtqml-syntax-directoryimports.html#directory-listing-qmldir-files">directory listing qmldir files</a>.</p>
<h2 id="contents-of-a-module-definition-qmldir-file">Contents of a Module Definition qmldir File</h2>
<p>A <code>qmldir</code> file is a plain-text file that contains the following commands:</p>
<div class="table"><table class="generic" width="70%">
 <thead><tr class="qt-style"><th >Syntax</th><th >Usage</th></tr></thead>
<tr valign="top" class="odd"><td ><pre class="cpp">
 module <span class="operator">&lt;</span>ModuleIdentifier<span class="operator">&gt;</span>
</pre>
</td><td >Declares the module identifier of the module. The &lt;ModuleIdentifier&gt; is the (dotted URI notation) identifier for the module, which must match the module's install path.<p>The <a href="qtqml-modules-identifiedmodules.html#semantics-of-identified-modules">module identifier directive</a> must be the first line of the file. Exactly one module identifier directive may exist in the <code>qmldir</code> file.</p>
<p>Example:</p>
<pre class="cpp">
 module ExampleModule
</pre>
</td></tr>
<tr valign="top" class="even"><td ><pre class="cpp">
 <span class="operator">[</span>singleton<span class="operator">]</span> <span class="operator">&lt;</span>TypeName<span class="operator">&gt;</span> <span class="operator">&lt;</span>InitialVersion<span class="operator">&gt;</span> <span class="operator">&lt;</span>File<span class="operator">&gt;</span>
</pre>
</td><td >Declares a <a href="qtqml-typesystem-objecttypes.html">QML object type</a> to be made available by the module.<ul>
<li><code>[singleton]</code> Optional. Used to declare a singleton type.</li>
<li><code>&lt;TypeName&gt;</code> is the type being made available</li>
<li><code>&lt;InitialVersion&gt;</code> is the module version for which the type is to be made available</li>
<li><code>&lt;File&gt;</code> is the (relative) file name of the QML file that defines the type</li>
</ul>
<p>Zero or more object type declarations may exist in the <code>qmldir</code> file, however each object type must have a unique type name within any particular version of the module.</p>
<div class="admonition note">
<p><b>Note: </b>To declare a <code>singleton</code> type, the QML file defining the type must include the <code>pragma Singleton</code> statement.</p>
</div>
<p>Example:</p>
<pre class="cpp">
 <span class="comment">//Style.qml with custom singleton type definition</span>
 pragma Singleton
 import <span class="type"><a href="../qtquick/qtquick-module.html">QtQuick</a></span> <span class="number">2.0</span>

 <span class="type"><a href="qml-qtqml-qtobject.html">QtObject</a></span> {
     property <span class="type">int</span> textSize: <span class="number">20</span>
     property color textColor: <span class="string">&quot;green&quot;</span>
 }

 <span class="comment">// qmldir declaring the singleton type</span>
 module CustomStyles
 singleton Style <span class="number">1.0</span> Style<span class="operator">.</span>qml

 <span class="comment">// singleton type in use</span>
 import <span class="type"><a href="../qtquick/qtquick-module.html">QtQuick</a></span> <span class="number">2.0</span>
 import CustomStyles <span class="number">1.0</span>

 Text {
     font<span class="operator">.</span>pixelSize: Style<span class="operator">.</span>textSize
     color: Style<span class="operator">.</span>textColor
     text: <span class="string">&quot;Hello World&quot;</span>
 }
</pre>
</td></tr>
<tr valign="top" class="odd"><td ><pre class="cpp">
 internal <span class="operator">&lt;</span>TypeName<span class="operator">&gt;</span> <span class="operator">&lt;</span>File<span class="operator">&gt;</span>
</pre>
</td><td >Declares an object type that is in the module but should not be made available to users of the module.<p>Zero or more internal object type declarations may exist in the <code>qmldir</code> file.</p>
<p>Example:</p>
<pre class="cpp">
 internal MyPrivateType MyPrivateType<span class="operator">.</span>qml
</pre>
<p>This is necessary if the module may be imported remotely (see <a href="qtqml-modules-identifiedmodules.html#remotely-installed-identified-modules">Remotely Installed Identified Modules</a>) because if an exported type depends on an non-exported type within the module, the engine must also load the non-exported type.</p>
</td></tr>
<tr valign="top" class="even"><td ><pre class="cpp">
 <span class="operator">&lt;</span>ResourceIdentifier<span class="operator">&gt;</span> <span class="operator">&lt;</span>InitialVersion<span class="operator">&gt;</span> <span class="operator">&lt;</span>File<span class="operator">&gt;</span>
</pre>
</td><td >Declares a JavaScript file to be made available by the module. The resource will be made available via the specified identifier with the specified version number.<p>Zero or more JavaScript resource declarations may exist in the <code>qmldir</code> file, however each JavaScript resource must have a unique identifier within any particular version of the module.</p>
<p>Example:</p>
<pre class="cpp">
 MyScript <span class="number">1.0</span> MyScript<span class="operator">.</span>js
</pre>
<p>See the documentation about <a href="qtqml-javascript-resources.html">defining JavaScript resources</a> and <a href="qtqml-javascript-imports.html">Importing JavaScript Resources In QML</a> for more information.</p>
</td></tr>
<tr valign="top" class="odd"><td ><pre class="cpp">
 <span class="operator">[</span>optional<span class="operator">]</span> plugin <span class="operator">&lt;</span>Name<span class="operator">&gt;</span> <span class="operator">[</span><span class="operator">&lt;</span>Path<span class="operator">&gt;</span><span class="operator">]</span>
</pre>
</td><td >Declares a plugin to be made available by the module.<ul>
<li><code>optional</code> denotes that the plugin itself does not contain any relevant code and only serves to load a library it links to. If given, and if any types for the module are already available, indicating that the library has been loaded by some other means, QML will not load the plugin.</li>
<li><code>&lt;Name&gt;</code> is the plugin library name. This is usually not the same as the file name of the plugin binary, which is platform dependent; e.g&#x2e; the library <code>MyAppTypes</code> would produce <code>libMyAppTypes.so</code> on Linux and <code>MyAppTypes.dll</code> on Windows.</li>
<li><code>&lt;Path&gt;</code> (optional) specifies either:<ul>
<li>an absolute path to the directory containing the plugin file, or</li>
<li>a relative path from the directory containing the <code>qmldir</code> file to the directory containing the plugin file.</li>
</ul>
<p>By default the engine searches for the plugin library in the directory that contains the <code>qmldir</code> file. (The plugin search path can be queried with <a href="qqmlengine.html#pluginPathList">QQmlEngine::pluginPathList</a>() and modified using <a href="qqmlengine.html#addPluginPath">QQmlEngine::addPluginPath</a>().)</p>
</li>
</ul>
<p>Zero or more C++ plugin declarations may exist in the <code>qmldir</code> file, however since plugin loading is a relatively expensive operation, clients are advised to specify at most a single plugin.</p>
<p>Example:</p>
<pre class="cpp">
 plugin MyPluginLibrary
</pre>
</td></tr>
<tr valign="top" class="even"><td ><pre class="cpp">
 classname <span class="operator">&lt;</span>C<span class="operator">+</span><span class="operator">+</span> plugin <span class="keyword">class</span><span class="operator">&gt;</span>
</pre>
</td><td >Provides the class name of the C++ plugin used by the module.<p>This information is required for all the QML modules that depend on a C++ plugin for additional functionality. Qt Quick applications built with static linking cannot resolve the module imports without this information.</p>
</td></tr>
<tr valign="top" class="odd"><td ><pre class="cpp">
 typeinfo <span class="operator">&lt;</span>File<span class="operator">&gt;</span>
</pre>
</td><td >Declares a <a href="qtqml-modules-qmldir.html#type-description-files">type description file</a> for the module that can be read by QML tools such as Qt Creator to access information about the types defined by the module's plugins. <code>&lt;File&gt;</code> is the (relative) file name of a <code>.qmltypes</code> file.<p>Example:</p>
<pre class="cpp">
 typeinfo mymodule<span class="operator">.</span>qmltypes
</pre>
<p>Without such a file, QML tools may be unable to offer features such as code completion for the types defined in your plugins.</p>
</td></tr>
<tr valign="top" class="even"><td ><pre class="cpp">
 depends <span class="operator">&lt;</span>ModuleIdentifier<span class="operator">&gt;</span> <span class="operator">&lt;</span>InitialVersion<span class="operator">&gt;</span>
</pre>
</td><td >Declares that this module depends on another.<p>Example:</p>
<pre class="cpp">
 depends MyOtherModule <span class="number">1.0</span>
</pre>
<p>This declaration is necessary only in cases when the dependency is hidden: for example, when the C++ code for one module is used to load QML (perhaps conditionally) which then depends on other modules. In such cases, the <code>depends</code> declaration is necessary to include the other modules in application packages.</p>
</td></tr>
<tr valign="top" class="odd"><td ><pre class="cpp">
 import <span class="operator">&lt;</span>ModuleIdentifier<span class="operator">&gt;</span> <span class="operator">[</span><span class="operator">&lt;</span>Version<span class="operator">&gt;</span><span class="operator">]</span>
</pre>
</td><td >Declares that this module imports another.<p>Example:</p>
<pre class="cpp">
 import MyOtherModule <span class="number">1.0</span>
</pre>
<p>The types from the other module are made available in the same type namespace as this module is imported into. Omitting the version imports the latest version available of the other module, specifying <code>auto</code> as version imports the same version as the version of this module specified in the QML <code>import</code> statement.</p>
</td></tr>
<tr valign="top" class="even"><td ><pre class="cpp">
 <span class="preprocessor"># &lt;Comment&gt;</span>
</pre>
</td><td >Declares a comment. These are ignored by the engine.<p>Example:</p>
<pre class="cpp">
 <span class="preprocessor"># this is a comment</span>
</pre>
</td></tr>
<tr valign="top" class="odd"><td ><pre class="cpp">
 designersupported
</pre>
</td><td >Set this property if the plugin is supported by Qt Quick Designer. By default, the plugin will not be supported.<p>A plugin that is supported by Qt Quick Designer has to be properly tested. This means that the plugin does not crash when running inside the qml2puppet that is used by Qt Quick Designer to execute QML. Generally the plugin should work well in the Qt Quick Designer and not cause any show stoppers, like taking huge amounts of memory, slowing down the qml2puppet heavily or anything else that renders the plugin effectively unusable in the Qt Quick Designer.</p>
<p>The items of an unsupported plugin are not painted in the Qt Quick Designer, but they are still available as empty boxes and the properties can be edited.</p>
</td></tr>
<tr valign="top" class="even"><td ><pre class="cpp">
 prefer <span class="operator">&lt;</span>Path<span class="operator">&gt;</span>
</pre>
</td><td >This property directs the QML engine to load any further files for this module from &lt;path&gt;, rather than the current directory. This can be used to load files compiled with qmlcachegen.<p>For example, you can add a module's QML files as resources to a resource path <code>:/my/path/MyModule/</code>. Then, add <code>prefer :/my/path/MyModule</code> to the qmldir file in order to use the files in the resource system, rather than the ones in the file system. If you then use qmlcachegen for those, the pre-compiled files will be available to any clients of the module.</p>
</td></tr>
</table></div>
<p>Each command in a <code>qmldir</code> file must be on a separate line.</p>
<h2 id="versioning-semantics">Versioning Semantics</h2>
<p>All QML types that are exported for a particular major version are available with the latest version of the same major version. For example, if a module provides a <code>MyButton</code> type in version 1.0 and <code>MyWindow</code> type in version 1.1, clients importing version <code>1.1</code> of the module get to use the <code>MyButton</code> and <code>MyWindow</code> types. However, the reverse is not true: a type exported for a particular minor version cannot be used by importing an older or earlier minor version. In the example mentioned earlier, if the client had imported version <code>1.0</code> of the module, they can use the <code>MyButton</code> type only but not the <code>MyWindow</code> type.</p>
<p>A module can offer multiple major versions but the clients have access to one major version only at a time. For example, importing <code>MyExampleModule 2.0</code> provides access to that major version only and not the previous major version. Although you can organize the artifacts that belong to different major versions under a sigle directory and a <code>qmldir</code> file, it is recommended to use different directories for each major version. If you choose to go with the earlier approach (one directory and a <code>qmldir</code> file), try to use the version suffix for the file names. For example, artifacts that belong to <code>MyExampleModule 2.0</code> can use <code>.2</code> suffix in their file name.</p>
<p>A version cannot be imported if no types have been explicitly exported for that version. If a module provides a <code>MyButton</code> type in version 1.0 and a <code>MyWindow</code> type in version 1.1, you cannot import version 1.2 or version 2.0 of that module.</p>
<p>A type can be defined by different files in different minor versions. In this case, the most closely matching version is used when imported by clients. For example, if a module had specified the following types via its <code>qmldir</code> file:</p>
<pre class="cpp">
 module ExampleModule
 MyButton <span class="number">1.0</span> MyButton<span class="operator">.</span>qml
 MyButton <span class="number">1.1</span> MyButton11<span class="operator">.</span>qml
 MyButton <span class="number">1.3</span> MyButton13<span class="operator">.</span>qml
 MyRectangle <span class="number">1.2</span> MyRectangle12<span class="operator">.</span>qml
</pre>
<p>a client who imports version <code>1.2</code> of <code>ExampleModule</code> can use the <code>MyButton</code> type definition provided by <code>MyButton11.qml</code> as it is the latest version of that type, and the <code>MyRectangle</code> type definition provided by <code>MyRectangle12.qml</code>.</p>
<p>The version system ensures that a given QML file works regardless of the version of installed software, as a versioned import only imports types for that version, leaving other identifiers available, even if the actual installed version might otherwise provide those identifiers.</p>
<h2 id="example-of-a-qmldir-file">Example of a qmldir File</h2>
<p>One example of a <code>qmldir</code> file follows:</p>
<pre class="cpp">
 module ExampleModule
 CustomButton <span class="number">2.0</span> CustomButton20<span class="operator">.</span>qml
 CustomButton <span class="number">2.1</span> CustomButton21<span class="operator">.</span>qml
 plugin examplemodule
 MathFunctions <span class="number">2.0</span> mathfuncs<span class="operator">.</span>js
</pre>
<p>The above <code>qmldir</code> file defines a module called &quot;ExampleModule&quot;. It defines the <code>CustomButton</code> QML object type in versions 2.0 and 2.1 of the module, with different implementations for each version. It specifies a plugin that must be loaded by the engine when the module is imported by clients, and that plugin may register various C++-defined types with the QML type system. On Unix-like systems the QML engine attempts to load <code>libexamplemodule.so</code> as a QQmlExtensionPlugin, and on Windows it loads <code>examplemodule.dll</code> as a QQmlExtensionPlugin. Finally, the <code>qmldir</code> file specifies a <a href="qtqml-javascript-resources.html">JavaScript resource</a>, which is only available if version 2.0 or a later version (under the same major version) of the module is imported.</p>
<p>If the module is <a href="qtqml-modules-identifiedmodules.html">installed</a> into the QML import path, clients could import and use the module in the following manner:</p>
<pre class="qml">
 import QtQuick 2.0
 import ExampleModule 2.1

 <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> {
     <span class="name">width</span>: <span class="number">400</span>
     <span class="name">height</span>: <span class="number">400</span>
     <span class="name">color</span>: <span class="string">&quot;lightsteelblue&quot;</span>

     <span class="type">CustomButton</span> {
         <span class="name">color</span>: <span class="string">&quot;gray&quot;</span>
         <span class="name">text</span>: <span class="string">&quot;Click Me!&quot;</span>
         <span class="name">onClicked</span>: <span class="name">MathFunctions</span>.<span class="name">generateRandom</span>() <span class="operator">&gt;</span> <span class="number">10</span> ? <span class="name">color</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span> : <span class="name">color</span> <span class="operator">=</span> <span class="string">&quot;gray&quot;</span>;
     }
 }
</pre>
<p>The <code>CustomButton</code> type used above would come from the definition specified in the <code>CustomButton21.qml</code> file, and the JavaScript resource identified by the <code>MathFunctions</code> identifier would be defined in the <code>mathfuncs.js</code> file.</p>
<h2 id="type-description-files">Type Description Files</h2>
<p>QML modules may refer to one or more type information files in their <code>qmldir</code> file. These usually have the <code>.qmltypes</code> extension and are read by external tools to gain information about types defined in C++ and typically imported via plugins.</p>
<p>As such qmltypes files have no effect on the functionality of a QML module. Their only use is to allow tools such as Qt Creator to provide code completion, error checking and other functionality to users of your module.</p>
<p>Any module that defines QML types in C++ should also ship a type description file.</p>
<p>The best way to create a qmltypes file for your module is to generate it using the build system and the <a href="qqmlengine.html#QML_ELEMENT">QML_ELEMENT</a> macros. If you follow the documentation on this, no further action is needed. qmltyperegistrar will automatically generate the <code>.qmltypes</code> files.</p>
<p>Example: If your module is in <code>/tmp/imports/My/Module</code>, a file caled <code>plugins.qmltypes</code> should be generated alongside the actual plugin binary.</p>
<p>Add the line</p>
<pre class="cpp">
 typeinfo plugins<span class="operator">.</span>qmltypes
</pre>
<p>to <code>/tmp/imports/My/Module/qmldir</code> to register it.</p>
</div>
<!-- @@@qtqml-modules-qmldir.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
