<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qquickgraphicsconfiguration.cpp -->
  <title>QQuickGraphicsConfiguration Class | Qt Quick 6.2.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 6.2</a></li>
<li><a href="qtquick-index.html">Qt Quick</a></li>
<li><a href="qtquick-module.html">C++ Classes</a></li>
<li>QQuickGraphicsConfiguration</li>
<li id="buildversion"><a href="qtquick-index.html">Qt 6.2&#x2e;3 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QQuickGraphicsConfiguration Class</h1>
<!-- $$$QQuickGraphicsConfiguration-brief -->
<p>The QQuickGraphicsConfiguration class is a container for low-level graphics settings that can affect how the underlying graphics API, such as Vulkan, is initialized by the Qt Quick scene graph. It can also control certain aspects of the scene graph renderer. <a href="#details">More...</a></p>
<!-- @@@QQuickGraphicsConfiguration -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QQuickGraphicsConfiguration&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Quick REQUIRED) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Quick)</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.0</td></tr></table></div>
<ul>
<li><a href="qquickgraphicsconfiguration-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#QQuickGraphicsConfiguration">QQuickGraphicsConfiguration</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#dtor.QQuickGraphicsConfiguration">~QQuickGraphicsConfiguration</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayList </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#deviceExtensions">deviceExtensions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#isDepthBufferEnabledFor2D">isDepthBufferEnabledFor2D</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setDepthBufferFor2D">setDepthBufferFor2D</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#setDeviceExtensions">setDeviceExtensions</a></b>(const QByteArrayList &amp;<i>extensions</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QByteArrayList </td><td class="memItemRight bottomAlign"><b><a href="qquickgraphicsconfiguration.html#preferredInstanceExtensions">preferredInstanceExtensions</a></b>()</td></tr>
</table></div>
<!-- $$$QQuickGraphicsConfiguration-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>When constructing and showing a <a href="qquickwindow.html">QQuickWindow</a> that uses Vulkan to render, a Vulkan instance (<code>VkInstance</code>), a physical device (<code>VkPhysicalDevice</code>), a device (<code>VkDevice</code>) and associated objects (queues, pools) are initialized through the Vulkan API. The same is mostly true when using <a href="qquickrendercontrol.html">QQuickRenderControl</a> to redirect the rendering into a custom render target, such as a texture. While <a href="../qtgui/qvulkaninstance.html">QVulkanInstance</a> construction is under the application's control then, the initialization of other graphics objects happen the same way in <a href="qquickrendercontrol.html#initialize">QQuickRenderControl::initialize</a>() as with an on-screen <a href="qquickwindow.html">QQuickWindow</a>.</p>
<p>For the majority of applications no additional configuration is needed because Qt Quick provides reasonable defaults for many low-level graphics settings, for example which device extensions to enable.</p>
<p>This will not alway be sufficient, however. In advanced use cases, when integrating direct Vulkan or other graphics API content, or when integrating with an external 3D or VR engine, such as, OpenXR, the application will want to specify its own set of settings when it comes to details, such as which device extensions to enable.</p>
<p>That is what this class enables. It allows specifying, for example, a list of device extensions that is then picked up by the scene graph when using Vulkan, or graphics APIs where the concept is applicable. Where some concepts are not applicable, the related settings are simply ignored.</p>
<p>Another class of settings are related to the scene graph's renderer. In some cases applications may want to control certain behavior,such as using the depth buffer when rendering 2D content. In Qt 5 such settings were either not controllable at all, or were managed through environment variables. In Qt 6, QQuickGraphicsConfiguration provides a new home for these settings, while keeping support for the legacy environment variables, where applicable.</p>
<div class="admonition note">
<p><b>Note: </b>Setting a QQuickGraphicsConfiguration on a <a href="qquickwindow.html">QQuickWindow</a> must happen early enough, before the scene graph is initialized for the first time for that window. With on-screen windows this means the call must be done before invoking show() on the <a href="qquickwindow.html">QQuickWindow</a> or <a href="qquickview.html">QQuickView</a>. With <a href="qquickrendercontrol.html">QQuickRenderControl</a> the configuration must be finalized before calling <a href="qquickrendercontrol.html#initialize">initialize</a>().</p>
</div>
</div>
<p><b>See also </b><a href="qquickwindow.html#setGraphicsConfiguration">QQuickWindow::setGraphicsConfiguration</a>(), <a href="qquickwindow.html">QQuickWindow</a>, and <a href="qquickrendercontrol.html">QQuickRenderControl</a>.</p>
<!-- @@@QQuickGraphicsConfiguration -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickGraphicsConfiguration[overload1]$$$QQuickGraphicsConfiguration -->
<h3 class="fn" id="QQuickGraphicsConfiguration">QQuickGraphicsConfiguration::<span class="name">QQuickGraphicsConfiguration</span>()</h3>
<p>Constructs a default QQuickGraphicsConfiguration that does not specify any additional settings for the scene graph to take into account.</p>
<!-- @@@QQuickGraphicsConfiguration -->
<!-- $$$~QQuickGraphicsConfiguration[overload1]$$$~QQuickGraphicsConfiguration -->
<h3 class="fn" id="dtor.QQuickGraphicsConfiguration">QQuickGraphicsConfiguration::<span class="name">~QQuickGraphicsConfiguration</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QQuickGraphicsConfiguration -->
<!-- $$$deviceExtensions[overload1]$$$deviceExtensions -->
<h3 class="fn" id="deviceExtensions"><span class="type"><a href="../qtcore/qbytearraylist.html">QByteArrayList</a></span> QQuickGraphicsConfiguration::<span class="name">deviceExtensions</span>() const</h3>
<p>Returns the list of the requested additional device extensions.</p>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#setDeviceExtensions">setDeviceExtensions</a>().</p>
<!-- @@@deviceExtensions -->
<!-- $$$isDepthBufferEnabledFor2D[overload1]$$$isDepthBufferEnabledFor2D -->
<h3 class="fn" id="isDepthBufferEnabledFor2D"><span class="type">bool</span> QQuickGraphicsConfiguration::<span class="name">isDepthBufferEnabledFor2D</span>() const</h3>
<p>Returns true if depth buffer usage is enabled for 2D content.</p>
<p>By default the value is true, unless the <code>QSG_NO_DEPTH_BUFFER</code> environment variable is set.</p>
<!-- @@@isDepthBufferEnabledFor2D -->
<!-- $$$preferredInstanceExtensions[overload1]$$$preferredInstanceExtensions -->
<h3 class="fn" id="preferredInstanceExtensions"><code>[static, since 6.1] </code><span class="type"><a href="../qtcore/qbytearraylist.html">QByteArrayList</a></span> QQuickGraphicsConfiguration::<span class="name">preferredInstanceExtensions</span>()</h3>
<p>Returns the list of Vulkan instance extensions Qt Quick prefers to have enabled on the VkInstance.</p>
<p>In most cases Qt Quick is responsible for creating a <a href="../qtgui/qvulkaninstance.html">QVulkanInstance</a>. This function is not relevant then. On the other hand, when using <a href="qquickrendercontrol.html">QQuickRenderControl</a> in combination with Vulkan-based rendering, it is the application's responsibility to create a <a href="../qtgui/qvulkaninstance.html">QVulkanInstance</a> and associate it with the (offscreen) <a href="qquickwindow.html">QQuickWindow</a>. In this case, it is expected that the application queries the list of instance extensions to enable, and passes them to <a href="../qtgui/qvulkaninstance.html#setExtensions">QVulkanInstance::setExtensions</a>() before calling <a href="../qtgui/qvulkaninstance.html#create">QVulkanInstance::create</a>().</p>
<p>This function was introduced in Qt 6.1.</p>
<!-- @@@preferredInstanceExtensions -->
<!-- $$$setDepthBufferFor2D[overload1]$$$setDepthBufferFor2Dbool -->
<h3 class="fn" id="setDepthBufferFor2D"><span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setDepthBufferFor2D</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>Sets the usage of depth buffer for 2D content to <i>enable</i>. When disabled, the Qt Quick scene graph never writes into the depth buffer.</p>
<p>By default the value is true, unless the <code>QSG_NO_DEPTH_BUFFER</code> environment variable is set.</p>
<p>The default value of true is the most optimal setting for the vast majority of scenes. Disabling depth buffer usage reduces the efficiency of the scene graph's batching.</p>
<p>There are cases however, when allowing the 2D content write to the depth buffer is not ideal. Consider a 3D scene as an &quot;overlay&quot; on top the 2D scene, rendered via Qt Quick 3D using a <a href="../qtquick3d/qml-qtquick3d-view3d.html">View3D</a> with <a href="../qtquick3d/qml-qtquick3d-view3d.html#renderMode-prop">renderMode</a> set to <code>Overlay</code>. In this case, having the depth buffer filled by 2D content can cause unexpected results. This is because the way the 2D scene graph renderer generates and handles depth values is not necessarily compatible with how a 3D scene works. This may end up in depth value clashes, collisions, and unexpected depth test failures. Therefore, the robust approach here is to call this function with <i>enable</i> set to false, and disable depth buffer writes for the 2D content in the <a href="qquickwindow.html">QQuickWindow</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This flag is not fully identical to setting the <code>QSG_NO_DEPTH_BUFFER</code> environment variable. This flag does not control the depth-stencil buffers' presence. It is rather relevant for the rendering pipeline. To force not having depth/stencil attachments at all, set <code>QSG_NO_DEPTH_BUFFER</code> and <code>QSG_NO_STENCIL_BUFFER</code>. Be aware however that such a <a href="qquickwindow.html">QQuickWindow</a>, and any Item layers in it, may then become incompatible with items, such as <a href="../qtquick3d/qml-qtquick3d-view3d.html">View3D</a> with certain operating modes, because 3D content requires a depth buffer. Calling this function is always safe, but can mean that resources, such as depth buffers, are created even though they are not actively used.</p>
</div>
<!-- @@@setDepthBufferFor2D -->
<!-- $$$setDeviceExtensions[overload1]$$$setDeviceExtensionsconstQByteArrayList& -->
<h3 class="fn" id="setDeviceExtensions"><span class="type">void</span> QQuickGraphicsConfiguration::<span class="name">setDeviceExtensions</span>(const <span class="type"><a href="../qtcore/qbytearraylist.html">QByteArrayList</a></span> &amp;<i>extensions</i>)</h3>
<p>Sets the list of additional <i>extensions</i> to enable on the graphics device (such as, the <code>VkDevice</code>).</p>
<p>When rendering with a graphics API where the concept is not applicable, <i>extensions</i> will be ignored.</p>
<div class="admonition note">
<p><b>Note: </b>The list specifies additional, extra extensions. Qt Quick always enables extensions that are required by the scene graph.</p>
</div>
<p><b>See also </b><a href="qquickgraphicsconfiguration.html#deviceExtensions">deviceExtensions</a>().</p>
<!-- @@@setDeviceExtensions -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2022 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
